/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type {
  IHttpHeader,
  IHttpParam,
  IHttpQuery,
  IHttpResponse,
} from "@rexeus/typeweaver-core";
import { RequestCommand } from "./RequestCommand";
import type { ProcessResponseOptions } from "./RequestCommand";

/**
 * Configuration options for handling unknown responses.
 */
export type UnknownResponseHandling = "throw" | "passthrough";

/**
 * Configuration options for ApiClient initialization.
 */
export type ApiClientProps = {
  /** Custom fetch function for HTTP requests. Defaults to globalThis.fetch */
  readonly fetchFn?: typeof globalThis.fetch;
  /** Base URL for API requests */
  readonly baseUrl: string;
  /** How to handle unknown responses. Defaults to "throw" */
  readonly unknownResponseHandling?: UnknownResponseHandling;
  /** Predicate to determine if a status code represents success. Defaults to 2xx status codes */
  readonly isSuccessStatusCode?: (statusCode: number) => boolean;
  /** Request timeout in milliseconds. When set, requests will be aborted after this duration */
  readonly timeoutMs?: number;
};

/**
 * Abstract base class for type-safe API clients.
 *
 * This class provides HTTP request execution with:
 * - Automatic path parameter substitution (`:param` style)
 * - Query string building with array support
 * - Network error handling with specific error messages
 * - Integration with RequestCommand pattern for type safety
 */
export abstract class ApiClient {
  private readonly fetchFn: typeof globalThis.fetch;
  public readonly baseUrl: string;
  public readonly unknownResponseHandling: UnknownResponseHandling;
  public readonly isSuccessStatusCode: (statusCode: number) => boolean;
  private readonly timeoutMs: number | undefined;

  protected constructor(props: ApiClientProps) {
    this.fetchFn = props.fetchFn ?? globalThis.fetch.bind(globalThis);
    this.baseUrl = props.baseUrl;

    if (!this.baseUrl) {
      throw new Error("Base URL must be provided");
    }

    if (
      props.timeoutMs !== undefined &&
      (props.timeoutMs <= 0 || !Number.isFinite(props.timeoutMs))
    ) {
      throw new Error("timeoutMs must be a positive finite number");
    }

    this.unknownResponseHandling = props.unknownResponseHandling ?? "throw";
    this.isSuccessStatusCode =
      props.isSuccessStatusCode ??
      ((statusCode: number) => statusCode >= 200 && statusCode < 300);
    this.timeoutMs = props.timeoutMs;
  }

  protected get processResponseOptions(): ProcessResponseOptions {
    return {
      unknownResponseHandling: this.unknownResponseHandling,
      isSuccessStatusCode: this.isSuccessStatusCode,
    };
  }

  protected async execute(request: RequestCommand): Promise<IHttpResponse> {
    const { method, path, header, query, param, body } = request;

    const pathWithParam = this.createPath(path, param);
    const relativeUrl = this.createUrl(pathWithParam, query);
    const fullUrl = this.buildFullUrl(relativeUrl);
    const serializedBody = this.serializeBody(body);

    let timedOut = false;
    const controller =
      this.timeoutMs !== undefined ? new AbortController() : undefined;
    const timeoutId = controller
      ? setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, this.timeoutMs)
      : undefined;

    let response: Response;
    try {
      response = await this.fetchFn(fullUrl, {
        method,
        headers: this.flattenHeaders(header),
        body: serializedBody,
        signal: controller?.signal,
      });
    } catch (error) {
      throw this.createNetworkError(error, method, fullUrl, timedOut);
    } finally {
      if (timeoutId !== undefined) clearTimeout(timeoutId);
    }

    return await this.createResponse(response);
  }

  private async createResponse(response: Response): Promise<IHttpResponse> {
    const header: IHttpHeader = {};
    response.headers.forEach((value, key) => {
      header[key] = value;
    });

    const body = await this.parseResponseBody(response);

    return {
      body,
      header,
      statusCode: response.status,
    };
  }

  private async parseResponseBody(response: Response): Promise<unknown> {
    if (response.status === 204) {
      return undefined;
    }

    const contentType = response.headers.get("content-type");

    if (this.isJsonContentType(contentType)) {
      const text = await response.text();
      if (!text) return undefined;
      try {
        return JSON.parse(text);
      } catch (parseError) {
        throw new Error(
          `Failed to parse JSON response (status ${response.status}). ` +
            `Body (first 200 chars): ${text.slice(0, 200)}`,
          {
            cause: parseError instanceof Error ? parseError : undefined,
          },
        );
      }
    }

    if (this.isTextContentType(contentType) || !contentType) {
      const text = await response.text();
      if (!text) return undefined;
      return text;
    }

    return await response.arrayBuffer();
  }

  private isTextContentType(contentType: string | null): boolean {
    if (!contentType) return false;
    return contentType.includes("text/");
  }

  private createNetworkError(
    error: unknown,
    method: string,
    url: string,
    timedOut: boolean,
  ): Error {
    const context = `(${method} ${url})`;

    if (
      (error instanceof DOMException || error instanceof Error) &&
      error.name === "AbortError"
    ) {
      const message = timedOut ? "Request timed out" : "Request aborted";
      return new Error(`Network error: ${message} ${context}`, {
        cause: error,
      });
    }

    if (error instanceof TypeError) {
      const cause = (error as TypeError & { cause?: { code?: string } }).cause;
      const code = cause?.code;

      const messageMap: Record<string, string> = {
        ECONNREFUSED: "Connection refused",
        ECONNRESET: "Connection reset by peer",
        ENOTFOUND: "DNS lookup failed",
        ETIMEDOUT: "Connection timed out",
      };

      if (code && code in messageMap) {
        return new Error(`Network error: ${messageMap[code]} ${context}`, {
          cause: error,
        });
      }
    }

    return new Error(
      `Network error: ${error instanceof Error ? error.message : String(error)} ${context}`,
      { cause: error instanceof Error ? error : undefined },
    );
  }

  private flattenHeaders(
    header: IHttpHeader,
  ): Record<string, string> | undefined {
    if (!header) return undefined;

    const flattened: Record<string, string> = {};
    for (const [key, value] of Object.entries(header)) {
      flattened[key] = Array.isArray(value) ? value.join(", ") : value;
    }
    return flattened;
  }

  private serializeBody(
    body: unknown,
  ): NonNullable<RequestInit["body"]> | undefined {
    if (body === undefined) return undefined;
    if (typeof body === "string") return body;
    if (this.isNativeBody(body))
      return body as NonNullable<RequestInit["body"]>;
    return JSON.stringify(body);
  }

  private isNativeBody(body: unknown): boolean {
    return (
      body instanceof Blob ||
      body instanceof ArrayBuffer ||
      body instanceof FormData ||
      body instanceof URLSearchParams ||
      body instanceof ReadableStream ||
      ArrayBuffer.isView(body)
    );
  }

  private isJsonContentType(contentType: string | null): boolean {
    if (!contentType) return false;
    return (
      contentType.includes("application/json") || contentType.includes("+json")
    );
  }

  private buildFullUrl(relativePath: string): string {
    const base = this.baseUrl.endsWith("/")
      ? this.baseUrl.slice(0, -1)
      : this.baseUrl;
    const path = relativePath.startsWith("/")
      ? relativePath
      : `/${relativePath}`;
    return `${base}${path}`;
  }

  private createPath(path: string, param?: IHttpParam): string {
    if (!param) {
      return path;
    }

    return Object.entries(param).reduce((acc, [key, value]) => {
      const result = acc.replace(`:${key}`, encodeURIComponent(value));

      if (result === acc) {
        throw new Error(
          `Path parameter '${key}' is not found in path '${path}'`,
        );
      }

      return result;
    }, path);
  }

  private createUrl(path: string, query?: IHttpQuery): string {
    const normalizedPath = path.startsWith("/") ? path : `/${path}`;
    const queryString = this.buildQueryString(query);
    return queryString ? `${normalizedPath}?${queryString}` : normalizedPath;
  }

  private buildQueryString(query?: IHttpQuery): string {
    if (!query) {
      return "";
    }

    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(query)) {
      if (value === undefined) {
        continue;
      }
      if (!Array.isArray(value)) {
        params.append(key, value);
        continue;
      }
      for (const item of value) {
        if (item !== undefined) {
          params.append(key, item);
        }
      }
    }
    return params.toString();
  }
}
