/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type {
  IHttpQuery,
  IHttpParam,
  IHttpHeader,
  IHttpResponse,
} from "@rexeus/typeweaver-core";
import { RequestCommand, type ProcessResponseOptions } from "./RequestCommand";
import axios, {
  AxiosError,
  type AxiosHeaderValue,
  type AxiosInstance,
  type AxiosResponse,
} from "axios";

/**
 * Configuration options for handling unknown responses.
 */
export type UnknownResponseHandling = "throw" | "passthrough";

/**
 * Configuration options for ApiClient initialization.
 */
export type ApiClientProps = {
  /** Custom Axios instance with pre-configured defaults */
  axiosInstance?: AxiosInstance;
  /** Base URL for API requests. If not provided, must be set in axiosInstance */
  baseUrl?: string;
  /** How to handle unknown responses. Defaults to "throw" */
  unknownResponseHandling?: UnknownResponseHandling;
  /** Predicate to determine if a status code represents success. Defaults to 2xx status codes */
  isSuccessStatusCode?: (statusCode: number) => boolean;
};

/**
 * Abstract base class for type-safe API clients.
 *
 * This class provides HTTP request execution with:
 * - Automatic path parameter substitution (`:param` style)
 * - Query string building with array support
 * - Header normalization (converts to Header-Case)
 * - Network error handling with specific error messages
 * - Integration with RequestCommand pattern for type safety
 */
export abstract class ApiClient {
  /** The Axios instance used for HTTP requests */
  public readonly axiosInstance: AxiosInstance;
  /** The base URL for all API requests */
  public readonly baseUrl: string;
  /** How to handle unknown responses */
  public readonly unknownResponseHandling: UnknownResponseHandling;
  /** Predicate to determine if a status code represents success */
  public readonly isSuccessStatusCode: (statusCode: number) => boolean;

  /**
   * Creates a new ApiClient instance.
   *
   * @param props - Configuration options
   * @throws {Error} If no base URL is provided in props or axios instance
   */
  protected constructor(props: ApiClientProps) {
    this.axiosInstance = props.axiosInstance ?? axios.create();

    this.baseUrl = props.baseUrl ?? this.axiosInstance.defaults.baseURL ?? "";
    if (!this.baseUrl) {
      throw new Error(
        "Base URL must be provided either in axios instance or in constructor",
      );
    }

    this.unknownResponseHandling = props.unknownResponseHandling ?? "throw";
    this.isSuccessStatusCode =
      props.isSuccessStatusCode ??
      ((statusCode: number) => statusCode >= 200 && statusCode < 300);
  }

  /**
   * Gets the process response options for this client instance.
   *
   * @returns The configuration options for processing responses
   * @protected
   */
  protected get processResponseOptions(): ProcessResponseOptions {
    return {
      unknownResponseHandling: this.unknownResponseHandling,
      isSuccessStatusCode: this.isSuccessStatusCode,
    };
  }

  /**
   * Executes an HTTP request using the provided command.
   *
   * This method:
   * 1. Substitutes path parameters (e.g., `:id` with actual values)
   * 2. Builds the complete URL with query parameters
   * 3. Sends the HTTP request via Axios
   * 4. Normalizes the response format
   * 5. Handles network errors with specific error messages
   *
   * @param request - The request command containing all HTTP parameters
   * @returns Promise resolving to the HTTP response
   * @throws {Error} Network errors with specific messages (connection refused, timeout, etc.)
   * @protected
   */
  protected async execute(request: RequestCommand): Promise<IHttpResponse> {
    const { method, path, header, query, param, body } = request;

    const headers = this.createHeader(header);
    const pathWithParam = this.createPath(path, param);
    const url = this.createUrl(pathWithParam, query);

    try {
      const response = await this.axiosInstance.request({
        method,
        url,
        data: body,
        headers,
      });

      return this.createResponse(response);
    } catch (error) {
      if (error instanceof AxiosError) {
        if (error.response) {
          return this.createResponse(error.response);
        }

        // TODO: improve network error handling
        if (error.code === "ECONNREFUSED") {
          throw new Error("Network error: Connection refused");
        }
        if (error.code === "ECONNRESET") {
          throw new Error("Network error: Connection reset by peer");
        }
        if (error.code === "ENOTFOUND") {
          throw new Error("Network error: DNS lookup failed");
        }
        if (error.code === "ETIMEDOUT") {
          throw new Error("Network error: Connection timed out");
        }

        throw new Error("Network error: Unknown error");
      }

      throw new Error(
        `Network error: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  private createResponse(response: AxiosResponse): IHttpResponse {
    const header: IHttpHeader = {};
    Object.entries(response.headers).forEach(([key, value]) => {
      this.addMultiValue(header, key, String(value));
    });

    return {
      body: response.data,
      header,
      statusCode: response.status,
    };
  }

  private createPath(path: string, param?: IHttpParam): string {
    if (!param) {
      return path;
    }

    return Object.entries(param).reduce((acc, [key, value]) => {
      const result = acc.replace(`:${key}`, value);

      if (result === acc) {
        throw new Error(
          `Path parameter '${key}' is not found in path '${path}'`,
        );
      }

      return result;
    }, path);
  }

  private addQuery(url: URL, query?: IHttpQuery): void {
    if (!query) {
      return;
    }

    const searchParams = url.searchParams;
    for (const [key, value] of Object.entries(query)) {
      if (!Array.isArray(value)) {
        searchParams.append(key, value);
        continue;
      }

      for (const item of value) {
        searchParams.append(key, item);
      }
    }
  }

  private createUrl(path: string, query?: IHttpQuery): string {
    const url = new URL(path, this.baseUrl);
    this.addQuery(url, query);
    return url.toString();
  }

  private createHeader(header: any): any {
    return header;
  }

  private addMultiValue(
    record: Record<string, string | string[]>,
    key: string,
    value: AxiosHeaderValue,
  ): void {
    const existing = record[key];
    const preparedValue = Array.isArray(value)
      ? value.map(String)
      : [String(value)];
    if (existing) {
      if (Array.isArray(existing)) {
        existing.push(...preparedValue);
      } else {
        record[key] = [existing, ...preparedValue];
      }
    } else {
      record[key] =
        preparedValue.length > 1 ? preparedValue : (preparedValue[0] as string);
    }
  }
}
