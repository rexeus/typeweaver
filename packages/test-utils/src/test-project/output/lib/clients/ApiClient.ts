/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type { IHttpHeader, IHttpParam, IHttpQuery, IHttpResponse } from "@rexeus/typeweaver-core";
import { NetworkError } from "./NetworkError";
import { PathParameterError } from "./PathParameterError";
import { RequestCommand } from "./RequestCommand";
import { ResponseParseError } from "./ResponseParseError";
import type { NetworkErrorCode } from "./NetworkError";
import type { ProcessResponseOptions } from "./RequestCommand";

/**
 * Configuration options for handling unknown responses.
 */
export type UnknownResponseHandling = "throw" | "passthrough";

/**
 * Configuration options for ApiClient initialization.
 */
export type ApiClientProps = {
  /** Custom fetch function for HTTP requests. Defaults to globalThis.fetch */
  readonly fetchFn?: typeof globalThis.fetch;
  /** Base URL for API requests */
  readonly baseUrl: string;
  /** How to handle unknown responses. Defaults to "throw" */
  readonly unknownResponseHandling?: UnknownResponseHandling;
  /** Predicate to determine if a status code represents success. Defaults to 2xx status codes */
  readonly isSuccessStatusCode?: (statusCode: number) => boolean;
  /** Request timeout in milliseconds. When set, requests will be aborted after this duration */
  readonly timeoutMs?: number;
};

const NETWORK_ERROR_MESSAGES: Readonly<Partial<Record<NetworkErrorCode, string>>> = {
  ECONNREFUSED: "Connection refused",
  ECONNRESET: "Connection reset by peer",
  ENOTFOUND: "DNS lookup failed",
  ETIMEDOUT: "Connection timed out",
};

/**
 * Abstract base class for type-safe API clients.
 *
 * This class provides HTTP request execution with:
 * - Automatic path parameter substitution (`:param` style)
 * - Query string building with array support
 * - Network error handling with specific error messages
 * - Integration with RequestCommand pattern for type safety
 */
export abstract class ApiClient {
  private readonly fetchFn: typeof globalThis.fetch;
  public readonly baseUrl: string;
  public readonly unknownResponseHandling: UnknownResponseHandling;
  public readonly isSuccessStatusCode: (statusCode: number) => boolean;
  private readonly timeoutMs: number | undefined;

  protected constructor(props: ApiClientProps) {
    this.fetchFn = props.fetchFn ?? globalThis.fetch.bind(globalThis);
    this.baseUrl = props.baseUrl;

    if (!this.baseUrl) {
      throw new Error("Base URL must be provided");
    }

    if (
      props.timeoutMs !== undefined &&
      (props.timeoutMs <= 0 || !Number.isFinite(props.timeoutMs))
    ) {
      throw new Error("timeoutMs must be a positive finite number");
    }

    this.unknownResponseHandling = props.unknownResponseHandling ?? "throw";
    this.isSuccessStatusCode =
      props.isSuccessStatusCode ?? ((statusCode: number) => statusCode >= 200 && statusCode < 300);
    this.timeoutMs = props.timeoutMs;
  }

  protected get processResponseOptions(): ProcessResponseOptions {
    return {
      unknownResponseHandling: this.unknownResponseHandling,
      isSuccessStatusCode: this.isSuccessStatusCode,
    };
  }

  protected async execute(request: RequestCommand): Promise<IHttpResponse> {
    const { method, path, header, query, param, body } = request;

    const pathWithParam = this.createPath(path, param);
    const relativeUrl = this.createUrl(pathWithParam, query);
    const fullUrl = this.buildFullUrl(relativeUrl);

    const response = await this.performFetch(method, fullUrl, {
      method,
      headers: this.flattenHeaders(header),
      body: this.serializeBody(body),
      signal: this.timeoutMs !== undefined ? AbortSignal.timeout(this.timeoutMs) : undefined,
    });

    return await this.createResponse(response, method, fullUrl);
  }

  private async performFetch(method: string, url: string, init: RequestInit): Promise<Response> {
    try {
      return await this.fetchFn(url, init);
    } catch (error) {
      throw this.createNetworkError(error, method, url);
    }
  }

  private async createResponse(
    response: Response,
    method: string,
    url: string,
  ): Promise<IHttpResponse> {
    const header: IHttpHeader = {};
    response.headers.forEach((value, key) => {
      header[key] = value;
    });

    if (typeof response.headers.getSetCookie === "function") {
      const cookies = response.headers.getSetCookie();
      if (cookies.length > 1) {
        header["set-cookie"] = cookies;
      }
    }

    const body = await this.parseResponseBody(response, method, url);

    return {
      body,
      header,
      statusCode: response.status,
    };
  }

  private async readBody<T>(
    read: () => Promise<T>,
    response: Response,
    method: string,
    url: string,
  ): Promise<T> {
    try {
      return await read();
    } catch (error) {
      throw new ResponseParseError(
        `Failed to read response body (${method} ${url})`,
        response.status,
        "",
        { cause: error instanceof Error ? error : undefined },
      );
    }
  }

  private async parseResponseBody(
    response: Response,
    method: string,
    url: string,
  ): Promise<unknown> {
    if (response.status === 204 || response.status === 304) {
      return undefined;
    }

    const contentType = response.headers.get("content-type");

    if (this.isJsonContentType(contentType)) {
      const text = await this.readBody(() => response.text(), response, method, url);
      if (!text) return undefined;
      try {
        return JSON.parse(text);
      } catch (parseError) {
        throw new ResponseParseError(
          "Failed to parse JSON response",
          response.status,
          text.slice(0, 200),
          {
            cause: parseError instanceof Error ? parseError : undefined,
          },
        );
      }
    }

    if (this.isTextContentType(contentType) || !contentType) {
      const text = await this.readBody(() => response.text(), response, method, url);
      if (!text) return undefined;
      return text;
    }

    return await this.readBody(() => response.arrayBuffer(), response, method, url);
  }

  private isTextContentType(contentType: string | null): boolean {
    if (!contentType) return false;
    return contentType.includes("text/");
  }

  private createNetworkError(error: unknown, method: string, url: string): NetworkError {
    const context = `(${method} ${url})`;

    if (
      (error instanceof DOMException || error instanceof Error) &&
      error.name === "TimeoutError"
    ) {
      return new NetworkError(
        `Network error: Request timed out ${context}`,
        "TIMEOUT",
        method,
        url,
        { cause: error },
      );
    }

    if ((error instanceof DOMException || error instanceof Error) && error.name === "AbortError") {
      return new NetworkError(`Network error: Request aborted ${context}`, "ABORT", method, url, {
        cause: error,
      });
    }

    if (error instanceof TypeError) {
      const cause = (error as TypeError & { cause?: { code?: string } }).cause;
      const code = cause?.code;

      if (code && code in NETWORK_ERROR_MESSAGES) {
        const message = NETWORK_ERROR_MESSAGES[code as NetworkErrorCode];
        return new NetworkError(
          `Network error: ${message} ${context}`,
          code as NetworkErrorCode,
          method,
          url,
          { cause: error },
        );
      }
    }

    return new NetworkError(
      `Network error: ${error instanceof Error ? error.message : String(error)} ${context}`,
      "UNKNOWN",
      method,
      url,
      { cause: error },
    );
  }

  private flattenHeaders(header: IHttpHeader): Record<string, string> | undefined {
    if (header === undefined) return undefined;

    const flattened: Record<string, string> = {};
    for (const [key, value] of Object.entries(header)) {
      flattened[key] = Array.isArray(value) ? value.join(", ") : value;
    }
    return flattened;
  }

  private serializeBody(body: unknown): NonNullable<RequestInit["body"]> | undefined {
    if (body === null || body === undefined) return undefined;
    if (typeof body === "string") return body;
    if (this.isNativeBody(body)) return body as NonNullable<RequestInit["body"]>;
    return JSON.stringify(body);
  }

  private isNativeBody(body: unknown): boolean {
    return (
      body instanceof Blob ||
      body instanceof ArrayBuffer ||
      body instanceof FormData ||
      body instanceof URLSearchParams ||
      body instanceof ReadableStream ||
      ArrayBuffer.isView(body)
    );
  }

  private isJsonContentType(contentType: string | null): boolean {
    if (!contentType) return false;
    return contentType.includes("application/json") || contentType.includes("+json");
  }

  private buildFullUrl(relativePath: string): string {
    const base = this.baseUrl.endsWith("/") ? this.baseUrl.slice(0, -1) : this.baseUrl;
    const path = relativePath.startsWith("/") ? relativePath : `/${relativePath}`;
    return `${base}${path}`;
  }

  private createPath(path: string, param?: IHttpParam): string {
    if (!param) {
      return path;
    }

    return Object.entries(param).reduce((acc, [key, value]) => {
      const result = acc.replace(`:${key}`, encodeURIComponent(value));

      if (result === acc) {
        throw new PathParameterError(
          `Path parameter '${key}' is not found in path '${path}'`,
          key,
          path,
        );
      }

      return result;
    }, path);
  }

  private createUrl(path: string, query?: IHttpQuery): string {
    const normalizedPath = path.startsWith("/") ? path : `/${path}`;
    const queryString = this.buildQueryString(query);
    return queryString ? `${normalizedPath}?${queryString}` : normalizedPath;
  }

  private buildQueryString(query?: IHttpQuery): string {
    if (!query) {
      return "";
    }

    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(query)) {
      if (value === undefined) {
        continue;
      }
      if (!Array.isArray(value)) {
        params.append(key, value);
        continue;
      }
      for (const item of value) {
        if (item !== undefined) {
          params.append(key, item);
        }
      }
    }
    return params.toString();
  }
}
