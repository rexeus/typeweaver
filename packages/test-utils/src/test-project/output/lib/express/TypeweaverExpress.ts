/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import { HttpResponse, RequestValidationError } from "@rexeus/typeweaver-core";
import { Router } from "express";
import type {
  IHttpRequest,
  IHttpResponse,
  IRequestValidator,
} from "@rexeus/typeweaver-core";
import { ExpressAdapter } from "./ExpressAdapter";
import type {
  ExpressRequestContext,
  ExpressRequestHandler,
} from "./ExpressRequestHandler";
import type {
  NextFunction,
  Request,
  Response,
  Router as ExpressRouter,
} from "express";

/**
 * Handles HTTP response errors thrown by request handlers.
 * @param error - The HTTP response error that was thrown
 * @param context - The Express context for the current request
 * @returns The HTTP response to send to the client
 */
export type HttpResponseErrorHandler = (
  error: HttpResponse,
  context: ExpressRequestContext,
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Handles request validation errors.
 * @param error - The validation error containing field-specific issues
 * @param context - The Express context for the current request
 * @returns The HTTP response to send to the client
 */
export type ValidationErrorHandler = (
  error: RequestValidationError,
  context: ExpressRequestContext,
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Handles any unknown errors not caught by other handlers.
 * @param error - The unknown error (could be anything)
 * @param context - The Express context for the current request
 * @returns The HTTP response to send to the client
 */
export type UnknownErrorHandler = (
  error: unknown,
  context: ExpressRequestContext,
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Configuration options for TypeweaverExpress routers.
 * @template RequestHandlers - Type containing all request handler methods
 */
export type TypeweaverExpressOptions<RequestHandlers> = {
  /**
   * Request handler methods for each operation.
   * Each handler receives a request (validated if `validateRequests` is true) and Express context.
   */
  readonly requestHandlers: RequestHandlers;

  /**
   * Enable request validation using generated validators.
   * When false, requests are passed through without validation.
   * @default true
   */
  readonly validateRequests?: boolean;

  /**
   * Configure handling of HttpResponse errors thrown by handlers.
   * - `true`: Use default handler (returns the error as-is)
   * - `false`: Let errors bubble up to Express error middleware
   * - `function`: Use custom error handler
   * @default true
   */
  readonly handleHttpResponseErrors?: HttpResponseErrorHandler | boolean;

  /**
   * Configure handling of request validation errors.
   * - `true`: Use default handler (400 with error details)
   * - `false`: Let errors bubble up to Express error middleware
   * - `function`: Use custom error handler
   * @default true
   */
  readonly handleValidationErrors?: ValidationErrorHandler | boolean;

  /**
   * Configure handling of unknown errors.
   * - `true`: Use default handler (500 Internal Server Error)
   * - `false`: Let errors bubble up to Express error middleware
   * - `function`: Use custom error handler
   * @default true
   */
  readonly handleUnknownErrors?: UnknownErrorHandler | boolean;
};

/**
 * Abstract base class for typeweaver-generated Express routers.
 *
 * Wraps an Express Router with typeweaver-specific features:
 * - Automatic request validation using generated validators
 * - Configurable error handling for validation, HTTP, and unknown errors
 * - Type-safe request/response handling with adapters
 *
 * @template RequestHandlers - Object containing typed request handler methods
 */
export abstract class TypeweaverExpress<RequestHandlers> {
  /**
   * The underlying Express Router instance.
   * Mount this on your Express app: `app.use(router.router)`
   */
  public readonly router: ExpressRouter;

  /**
   * Adapter for converting between Express and typeweaver request/response formats.
   */
  protected readonly adapter = new ExpressAdapter();

  /**
   * Request handlers provided during construction.
   */
  protected readonly requestHandlers: RequestHandlers;

  /**
   * Resolved configuration for validation and error handling.
   */
  private readonly config: {
    readonly validateRequests: boolean;
    readonly errorHandlers: {
      readonly validation: ValidationErrorHandler | undefined;
      readonly httpResponse: HttpResponseErrorHandler | undefined;
      readonly unknown: UnknownErrorHandler | undefined;
    };
  };

  /**
   * Default error handlers used when custom handlers are not provided.
   */
  private readonly defaultHandlers = {
    validation: (error: RequestValidationError): IHttpResponse => ({
      statusCode: 400,
      body: {
        code: "VALIDATION_ERROR",
        message: error.message,
        issues: {
          header: error.headerIssues,
          body: error.bodyIssues,
          query: error.queryIssues,
          param: error.pathParamIssues,
        },
      },
    }),

    httpResponse: (error: HttpResponse): IHttpResponse => error,

    unknown: (): IHttpResponse => ({
      statusCode: 500,
      body: {
        code: "INTERNAL_SERVER_ERROR",
        message: "An unexpected error occurred.",
      },
    }),
  };

  /**
   * Creates a new TypeweaverExpress router instance.
   *
   * @param options - Configuration options including request handlers and error handling
   */
  public constructor(options: TypeweaverExpressOptions<RequestHandlers>) {
    const {
      requestHandlers,
      validateRequests = true,
      handleHttpResponseErrors,
      handleValidationErrors,
      handleUnknownErrors,
    } = options;

    this.router = Router();
    this.requestHandlers = requestHandlers;

    this.config = {
      validateRequests,
      errorHandlers: {
        validation: this.resolveErrorHandler(handleValidationErrors, (error) =>
          this.defaultHandlers.validation(error),
        ),
        httpResponse: this.resolveErrorHandler(
          handleHttpResponseErrors,
          (error) => this.defaultHandlers.httpResponse(error),
        ),
        unknown: this.resolveErrorHandler(handleUnknownErrors, () =>
          this.defaultHandlers.unknown(),
        ),
      },
    };

    this.setupRoutes();
  }

  /**
   * Abstract method to be implemented by generated routers.
   * Sets up all routes on the internal Express Router.
   */
  protected abstract setupRoutes(): void;

  /**
   * Resolves error handler configuration to a handler function or undefined.
   *
   * @param option - Boolean to enable/disable or custom handler function
   * @param defaultHandler - Default handler to use when option is true
   * @returns Resolved handler function or undefined if disabled
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private resolveErrorHandler<T extends (...args: any[]) => any>(
    option: T | boolean | undefined,
    defaultHandler: T,
  ): T | undefined {
    if (option === false) return undefined;
    if (option === true || option === undefined) return defaultHandler;
    return option;
  }

  /**
   * Safely executes an error handler and returns null if it fails.
   * This allows for graceful fallback to the next handler in the chain.
   *
   * @param handlerFn - Function that executes the error handler
   * @returns Response if successful, null if handler throws
   */
  private async safelyExecuteHandler(
    handlerFn: () => Promise<IHttpResponse> | IHttpResponse,
  ): Promise<IHttpResponse | null> {
    try {
      return await handlerFn();
    } catch {
      return null;
    }
  }

  /**
   * Handles an error and sends the appropriate response.
   *
   * @param error - The error that occurred
   * @param context - The Express context
   */
  protected async handleError(
    error: unknown,
    context: ExpressRequestContext,
  ): Promise<void> {
    const { res, next } = context;

    // Handle validation errors
    if (
      error instanceof RequestValidationError &&
      this.config.errorHandlers.validation
    ) {
      const response = await this.safelyExecuteHandler(() =>
        this.config.errorHandlers.validation!(error, context),
      );
      if (response) {
        this.adapter.sendResponse(response, res);
        return;
      }
    }

    // Handle HTTP response errors
    if (
      error instanceof HttpResponse &&
      this.config.errorHandlers.httpResponse
    ) {
      const response = await this.safelyExecuteHandler(() =>
        this.config.errorHandlers.httpResponse!(error, context),
      );
      if (response) {
        this.adapter.sendResponse(response, res);
        return;
      }
    }

    // Handle unknown errors
    if (this.config.errorHandlers.unknown) {
      const response = await this.safelyExecuteHandler(() =>
        this.config.errorHandlers.unknown!(error, context),
      );
      if (response) {
        this.adapter.sendResponse(response, res);
        return;
      }
    }

    // Pass to Express error middleware
    next(error);
  }

  /**
   * Handles a request with validation and type-safe response conversion.
   * This is called from the generated route handlers.
   *
   * @param req - The Express Request object
   * @param res - The Express Response object
   * @param next - The Express NextFunction
   * @param validator - Request validator for the specific operation
   * @param handler - Type-safe request handler function
   */
  protected async handleRequest<
    TRequest extends IHttpRequest,
    TResponse extends IHttpResponse,
  >(
    req: Request,
    res: Response,
    next: NextFunction,
    validator: IRequestValidator,
    handler: ExpressRequestHandler<TRequest, TResponse>,
  ): Promise<void> {
    const context: ExpressRequestContext = { req, res, next };

    try {
      const httpRequest = await this.adapter.toRequest(req);

      // Conditionally validate
      const validatedRequest = this.config.validateRequests
        ? (validator.validate(httpRequest) as TRequest)
        : (httpRequest as TRequest);

      const httpResponse = await handler(validatedRequest, context);
      this.adapter.sendResponse(httpResponse, res);
    } catch (error) {
      await this.handleError(error, context);
    }
  }
}
