/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type { IHttpResponse } from "@rexeus/typeweaver-core";
import type { ServerContext } from "./ServerContext";

/**
 * A middleware function that processes requests in the pipeline.
 *
 * Follows a return-based onion model: call `next()` to pass control to the next
 * middleware or handler and receive the response, then return it (optionally modified).
 *
 * To short-circuit the pipeline, return a response without calling `next()`.
 *
 * @example
 * ```typescript
 * // Logging middleware
 * const logger: Middleware = async (ctx, next) => {
 *   const start = Date.now();
 *   const response = await next();
 *   console.log(`${ctx.request.method} ${ctx.request.path} -> ${response.statusCode} (${Date.now() - start}ms)`);
 *   return response;
 * };
 *
 * // Auth guard (short-circuit)
 * const auth: Middleware = async (ctx, next) => {
 *   if (!ctx.request.header?.["authorization"]) {
 *     return { statusCode: 401, body: { message: "Unauthorized" } };
 *   }
 *   return next();
 * };
 * ```
 */
export type Middleware = (
  ctx: ServerContext,
  next: () => Promise<IHttpResponse>,
) => Promise<IHttpResponse>;

/**
 * Internal representation of a registered middleware with optional path scope.
 */
export type MiddlewareEntry = {
  /** Path pattern to match. `undefined` means global (matches all paths). */
  path: string | undefined;
  /** The middleware function. */
  handler: Middleware;
};

/**
 * Executes a middleware pipeline in onion order (return-based).
 *
 * Each middleware receives a `next()` function that invokes the next
 * middleware in the chain and returns its response. The final `next()`
 * calls the provided `finalHandler`.
 *
 * @param middlewares - Ordered list of middleware functions to execute
 * @param ctx - The server context shared across the pipeline
 * @param finalHandler - The handler to execute after all middleware
 * @returns The response produced by the pipeline
 */
export async function executeMiddlewarePipeline(
  middlewares: Middleware[],
  ctx: ServerContext,
  finalHandler: () => Promise<IHttpResponse>,
): Promise<IHttpResponse> {
  let index = 0;

  const next = async (): Promise<IHttpResponse> => {
    if (index < middlewares.length) {
      const currentIndex = index++;
      let called = false;

      return middlewares[currentIndex]!(ctx, async () => {
        if (called) {
          throw new Error("next() called multiple times");
        }
        called = true;
        return next();
      });
    } else {
      return finalHandler();
    }
  };

  return next();
}
