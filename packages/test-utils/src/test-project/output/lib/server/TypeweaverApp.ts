/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import { HttpResponse, RequestValidationError } from "@rexeus/typeweaver-core";
import type { IHttpResponse } from "@rexeus/typeweaver-core";
import { FetchApiAdapter, BodyParseError } from "./FetchApiAdapter";
import type { Middleware, MiddlewareEntry } from "./Middleware";
import { executeMiddlewarePipeline } from "./Middleware";
import {
  Router,
  type RouteDefinition,
  type HttpResponseErrorHandler,
  type ValidationErrorHandler,
  type UnknownErrorHandler,
} from "./Router";
import type { ServerContext } from "./ServerContext";
import type { TypeweaverRouter } from "./TypeweaverRouter";

/**
 * The main application class that provides routing, middleware, and
 * request handling — all using typeweaver's native `IHttpRequest`/`IHttpResponse` format.
 *
 * Exposes a single `fetch()` method compatible with Bun, Deno, Cloudflare Workers,
 * and adaptable to Node.js `http.createServer`.
 *
 * Internally, the entire pipeline operates on `IHttpRequest`/`IHttpResponse`.
 * Conversion from/to Fetch API `Request`/`Response` happens **only** at the boundary.
 *
 * Middleware is return-based: each middleware returns an `IHttpResponse`
 * instead of mutating shared state.
 *
 * Middleware runs for **all** requests, including 404s and 405s, so global
 * concerns like logging and CORS always execute.
 *
 * @example
 * ```typescript
 * const app = new TypeweaverApp();
 *
 * // Global middleware
 * app.use(async (ctx, next) => {
 *   console.log(`${ctx.request.method} ${ctx.request.path}`);
 *   return next();
 * });
 *
 * // Path-scoped middleware (short-circuit)
 * app.use("/todos/*", async (ctx, next) => {
 *   const token = ctx.request.header?.["authorization"];
 *   if (!token) {
 *     return { statusCode: 401, body: { message: "Unauthorized" } };
 *   }
 *   return next();
 * });
 *
 * // Mount generated routers
 * app.route(new AccountRouter({ requestHandlers: { ... } }));
 * app.route("/api/v1", new TodoRouter({ requestHandlers: { ... } }));
 *
 * // Start
 * Bun.serve({ fetch: app.fetch, port: 3000 });
 * ```
 */
export class TypeweaverApp {
  private readonly router = new Router();
  private readonly middlewares: MiddlewareEntry[] = [];
  private readonly adapter = new FetchApiAdapter();

  /**
   * Register a global middleware that runs for all requests.
   */
  public use(middleware: Middleware): this;

  /**
   * Register a path-scoped middleware that runs only for matching paths.
   *
   * Supports wildcard patterns: `/todos/*` matches `/todos/123`, `/todos/123/subtodos`, etc.
   */
  public use(path: string, middleware: Middleware): this;

  public use(
    pathOrMiddleware: string | Middleware,
    middleware?: Middleware,
  ): this {
    if (typeof pathOrMiddleware === "string") {
      this.middlewares.push({
        path: pathOrMiddleware,
        handler: middleware!,
      });
    } else {
      this.middlewares.push({
        path: undefined,
        handler: pathOrMiddleware,
      });
    }
    return this;
  }

  /**
   * Mount a generated `TypeweaverRouter` instance.
   *
   * Registers all routes from the router into the app.
   * Multiple routers can be mounted on the same app.
   *
   * Optionally accepts a prefix to prepend to all routes from the router.
   *
   * @example
   * ```typescript
   * app.route(new AccountRouter({ requestHandlers: { ... } }));
   * app.route("/api/v1", new TodoRouter({ requestHandlers: { ... } }));
   * ```
   */
  public route(router: TypeweaverRouter<any>): this;
  public route(prefix: string, router: TypeweaverRouter<any>): this;
  public route(
    prefixOrRouter: string | TypeweaverRouter<any>,
    router?: TypeweaverRouter<any>,
  ): this {
    const actualPrefix =
      typeof prefixOrRouter === "string" ? prefixOrRouter : undefined;
    const actualRouter =
      typeof prefixOrRouter === "string" ? router! : prefixOrRouter;

    for (const route of actualRouter.getRoutes()) {
      if (actualPrefix) {
        // Normalize: ensure prefix doesn't have trailing slash
        const normalizedPrefix = actualPrefix.replace(/\/+$/, "");
        this.router.add({
          ...route,
          path: normalizedPrefix + route.path,
        });
      } else {
        this.router.add(route);
      }
    }
    return this;
  }

  /**
   * Universal request handler compatible with Fetch API runtimes.
   *
   * The entire pipeline works with `IHttpRequest`/`IHttpResponse`.
   * Conversion from/to Fetch API `Request`/`Response` happens only here, at the boundary.
   *
   * Middleware runs for all requests (including 404s and 405s).
   * HEAD requests automatically fall back to GET handlers with body stripped from the response.
   *
   * @example
   * ```typescript
   * // Bun
   * Bun.serve({ fetch: app.fetch, port: 3000 });
   *
   * // Deno
   * Deno.serve({ port: 3000 }, app.fetch);
   * ```
   */
  public fetch = async (request: Request): Promise<Response> => {
    // --- BOUNDARY IN: Parse URL once, reuse everywhere ---
    const url = new URL(request.url);
    const isHead = request.method.toUpperCase() === "HEAD";

    let httpRequest;
    try {
      // Convert request early so middleware always has access
      httpRequest = await this.adapter.toRequest(request, undefined, url);
    } catch (error) {
      // Body parse errors at the boundary
      return this.adapter.toResponse(this.handleBoundaryError(error));
    }

    // --- INTERNAL: Everything is IHttpRequest/IHttpResponse ---
    const ctx: ServerContext = {
      request: httpRequest,
      state: new Map(),
    };

    // Collect matching middleware based on path
    const matchingMiddleware = this.middlewares
      .filter((m) => Router.matchesMiddlewarePath(m.path, httpRequest.path))
      .map((m) => m.handler);

    let response: IHttpResponse;

    try {
      // Execute middleware pipeline → route matching → handler
      response = await executeMiddlewarePipeline(matchingMiddleware, ctx, () =>
        this.resolveAndExecute(request.method, url.pathname, ctx),
      );
    } catch (error) {
      response = this.handleBoundaryError(error);
    }

    // --- BOUNDARY OUT: IHttpResponse → Fetch API Response ---
    // For HEAD requests, strip the body from the response
    if (isHead) {
      response = { ...response, body: undefined };
    }

    return this.adapter.toResponse(response);
  };

  /**
   * Match the route and execute the handler.
   * Called as the final handler in the middleware pipeline.
   */
  private async resolveAndExecute(
    method: string,
    pathname: string,
    ctx: ServerContext,
  ): Promise<IHttpResponse> {
    const match = this.router.match(method, pathname);

    if (match) {
      // Inject extracted path params into the request
      if (Object.keys(match.params).length > 0) {
        ctx.request = { ...ctx.request, param: match.params };
      }

      try {
        return await this.executeHandler(ctx, match.route);
      } catch (error) {
        return this.handleError(error, ctx, match.route);
      }
    }

    // No method match — check if path exists (405 vs 404)
    const pathMatch = this.router.matchPath(pathname);
    if (pathMatch) {
      const allowedMethods = Router.getAllowedMethods(pathMatch.node);
      return {
        statusCode: 405,
        header: { Allow: allowedMethods.join(", ") },
        body: { code: "METHOD_NOT_ALLOWED", message: "Method Not Allowed" },
      };
    }

    return {
      statusCode: 404,
      body: { code: "NOT_FOUND", message: "Not Found" },
    };
  }

  /**
   * Execute the route handler with optional validation.
   */
  private async executeHandler(
    ctx: ServerContext,
    route: RouteDefinition,
  ): Promise<IHttpResponse> {
    // Validate request if enabled
    const validatedRequest = route.routerConfig.validateRequests
      ? route.validator.validate(ctx.request)
      : ctx.request;

    // Call handler — returns IHttpResponse directly
    return route.handler(validatedRequest, ctx);
  }

  /**
   * Handle errors at the boundary level (before route matching).
   * Catches BodyParseError from the adapter.
   */
  private handleBoundaryError(error: unknown): IHttpResponse {
    if (error instanceof BodyParseError) {
      return {
        statusCode: 400,
        body: {
          code: "BAD_REQUEST",
          message: error.message,
        },
      };
    }

    return {
      statusCode: 500,
      body: {
        code: "INTERNAL_SERVER_ERROR",
        message: "An unexpected error occurred.",
      },
    };
  }

  /**
   * Handle errors using the route's configured error handlers.
   */
  private async handleError(
    error: unknown,
    ctx: ServerContext,
    route: RouteDefinition,
  ): Promise<IHttpResponse> {
    const config = route.routerConfig;

    // Handle validation errors
    if (error instanceof RequestValidationError) {
      const handler = this.resolveErrorHandler<ValidationErrorHandler>(
        config.handleValidationErrors,
        (err): IHttpResponse => ({
          statusCode: 400,
          body: {
            code: "VALIDATION_ERROR",
            message: err.message,
            issues: {
              header: err.headerIssues,
              body: err.bodyIssues,
              query: err.queryIssues,
              param: err.pathParamIssues,
            },
          },
        }),
      );
      if (handler) {
        try {
          return await handler(error, ctx);
        } catch {
          // Handler failed, fall through
        }
      }
    }

    // Handle HTTP response errors (thrown HttpResponse instances)
    if (error instanceof HttpResponse) {
      const handler = this.resolveErrorHandler<HttpResponseErrorHandler>(
        config.handleHttpResponseErrors,
        (err): IHttpResponse => err,
      );
      if (handler) {
        try {
          return await handler(error, ctx);
        } catch {
          // Handler failed, fall through
        }
      }
    }

    // Handle unknown errors
    const handler = this.resolveErrorHandler<UnknownErrorHandler>(
      config.handleUnknownErrors,
      (): IHttpResponse => ({
        statusCode: 500,
        body: {
          code: "INTERNAL_SERVER_ERROR",
          message: "An unexpected error occurred.",
        },
      }),
    );
    if (handler) {
      try {
        return await handler(error, ctx);
      } catch {
        // Handler also failed
      }
    }

    // Last resort
    return {
      statusCode: 500,
      body: {
        code: "INTERNAL_SERVER_ERROR",
        message: "An unexpected error occurred.",
      },
    };
  }

  /**
   * Resolve an error handler option to a concrete handler function.
   */
  private resolveErrorHandler<T extends (...args: any[]) => any>(
    option: T | boolean | undefined,
    defaultHandler: T,
  ): T | undefined {
    if (option === false) return undefined;
    if (option === true || option === undefined) return defaultHandler;
    return option;
  }
}
