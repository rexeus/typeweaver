/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type {
  IHttpRequest,
  IHttpResponse,
  IRequestValidator,
} from "@rexeus/typeweaver-core";
import type { RequestHandler } from "./RequestHandler";

/**
 * A registered route with its method, path pattern, validator, and handler.
 */
export type RouteDefinition = {
  method: string;
  path: string;
  validator: IRequestValidator;
  handler: RequestHandler<any, any>;
  /** Reference to the router config for error handling. */
  routerConfig: RouterErrorConfig;
};

/**
 * Error handling configuration associated with a router.
 */
export type RouterErrorConfig = {
  validateRequests: boolean;
  handleHttpResponseErrors: HttpResponseErrorHandler | boolean;
  handleValidationErrors: ValidationErrorHandler | boolean;
  handleUnknownErrors: UnknownErrorHandler | boolean;
};

import type { ServerContext } from "./ServerContext";

/**
 * Handles HTTP response errors thrown by request handlers.
 */
export type HttpResponseErrorHandler = (
  error: IHttpResponse,
  ctx: ServerContext,
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Handles request validation errors.
 */
export type ValidationErrorHandler = (
  error: import("@rexeus/typeweaver-core").RequestValidationError,
  ctx: ServerContext,
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Handles any unknown errors not caught by other handlers.
 */
export type UnknownErrorHandler = (
  error: unknown,
  ctx: ServerContext,
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Result of a successful route match.
 */
export type RouteMatch = {
  route: RouteDefinition;
  params: Record<string, string>;
};

/**
 * Result of a path-only match (node found, but method may not exist).
 */
export type PathMatch = {
  node: RadixNode;
  params: Record<string, string>;
};

/**
 * A node in the radix tree.
 *
 * Each node represents a single path segment.
 * Static children are stored in a `Map` keyed by segment string.
 * A single `paramChild` holds the branch for `:param` segments.
 * Leaf nodes store a `Map` of HTTP method → route definition.
 */
export type RadixNode = {
  /** Static segment children: segment string → child node. */
  staticChildren: Map<string, RadixNode>;
  /** Child node for parameterized segments (`:param`). */
  paramChild: { name: string; node: RadixNode } | undefined;
  /** Route definitions at this node, keyed by HTTP method. */
  methods: Map<string, RouteDefinition>;
};

/**
 * Creates a new empty radix node.
 */
function createNode(): RadixNode {
  return {
    staticChildren: new Map(),
    paramChild: undefined,
    methods: new Map(),
  };
}

/**
 * High-performance radix tree router with path parameter support.
 *
 * Routes are stored in a tree structure where each level corresponds
 * to a path segment. This gives O(d) lookup time where d is the depth
 * (number of segments) of the URL — independent of the total number
 * of registered routes.
 *
 * Supports:
 * - Static paths: `/accounts`
 * - Named parameters: `/todos/:todoId`
 * - Multiple parameters: `/todos/:todoId/subtodos/:subtodoId`
 * - Automatic HEAD → GET fallback (per HTTP spec)
 * - 405 Method Not Allowed detection with `Allow` header
 *
 * Path matching for middleware uses wildcard support:
 * - `/todos/*` matches `/todos/123`, `/todos/123/subtodos`, etc.
 */
export class Router {
  private readonly root: RadixNode = createNode();

  /**
   * Register a route in the radix tree.
   */
  public add(definition: RouteDefinition): void {
    const segments = this.toSegments(definition.path);
    const method = definition.method.toUpperCase();

    let current = this.root;

    for (const segment of segments) {
      if (segment.startsWith(":")) {
        const paramName = segment.slice(1);
        if (!current.paramChild) {
          current.paramChild = { name: paramName, node: createNode() };
        }
        current = current.paramChild.node;
      } else {
        let child = current.staticChildren.get(segment);
        if (!child) {
          child = createNode();
          current.staticChildren.set(segment, child);
        }
        current = child;
      }
    }

    current.methods.set(method, definition);
  }

  /**
   * Find a matching route for the given method and path.
   *
   * Traverses the radix tree in O(d) time where d is the number
   * of path segments. Static segments are matched first (exact match),
   * then parameterized segments are tried as fallback.
   *
   * For HEAD requests, automatically falls back to the GET handler
   * if no explicit HEAD handler is registered (per HTTP spec).
   *
   * @returns The matched route with extracted path parameters, or `undefined` if no match.
   */
  public match(method: string, path: string): RouteMatch | undefined {
    const upperMethod = method.toUpperCase();
    const segments = this.toSegments(path);
    const params: Record<string, string> = {};

    const node = this.traverse(this.root, segments, 0, params);
    if (!node) return undefined;

    let definition = node.methods.get(upperMethod);

    // HEAD falls back to GET per HTTP spec
    if (!definition && upperMethod === "HEAD") {
      definition = node.methods.get("GET");
    }

    if (!definition) return undefined;

    return { route: definition, params };
  }

  /**
   * Find a matching node for the given path, regardless of HTTP method.
   *
   * Used to distinguish "path not found" (404) from "method not allowed" (405).
   *
   * @returns The matched node and params, or `undefined` if the path doesn't exist.
   */
  public matchPath(path: string): PathMatch | undefined {
    const segments = this.toSegments(path);
    const params: Record<string, string> = {};

    const node = this.traverse(this.root, segments, 0, params);
    if (!node || node.methods.size === 0) return undefined;

    return { node, params };
  }

  /**
   * Get the list of allowed HTTP methods for a matched node.
   *
   * If a GET handler exists, HEAD is implicitly allowed.
   */
  public static getAllowedMethods(node: RadixNode): string[] {
    const methods = Array.from(node.methods.keys());
    // HEAD is implicitly allowed when GET exists
    if (methods.includes("GET") && !methods.includes("HEAD")) {
      methods.push("HEAD");
    }
    return methods.sort();
  }

  /**
   * Check if a request path matches a middleware path pattern.
   *
   * Supports wildcard (`*`) at the end: `/todos/*` matches `/todos/123/subtodos`.
   * An `undefined` pattern matches everything.
   */
  public static matchesMiddlewarePath(
    pattern: string | undefined,
    requestPath: string,
  ): boolean {
    if (pattern === undefined) return true;

    // Exact match
    if (pattern === requestPath) return true;

    // Wildcard: /foo/* matches /foo/anything
    if (pattern.endsWith("/*")) {
      const prefix = pattern.slice(0, -1); // "/foo/"
      return (
        requestPath.startsWith(prefix) || requestPath === pattern.slice(0, -2)
      );
    }

    return false;
  }

  /**
   * Recursively traverse the radix tree to find a matching node.
   *
   * Prioritises static children over param children for correct
   * and predictable matching behaviour.
   *
   * Path parameters are URL-decoded during extraction.
   */
  private traverse(
    node: RadixNode,
    segments: string[],
    index: number,
    params: Record<string, string>,
  ): RadixNode | undefined {
    // All segments consumed — this node is the match candidate
    if (index === segments.length) {
      return node;
    }

    const segment = segments[index]!;

    // 1. Try static child first (higher priority)
    const staticChild = node.staticChildren.get(segment);
    if (staticChild) {
      const result = this.traverse(staticChild, segments, index + 1, params);
      if (result && result.methods.size > 0) return result;
    }

    // 2. Try param child as fallback
    if (node.paramChild) {
      const { name, node: paramNode } = node.paramChild;
      params[name] = decodePathSegment(segment);
      const result = this.traverse(paramNode, segments, index + 1, params);
      if (result && result.methods.size > 0) return result;
      // Backtrack: remove param if this branch didn't match
      delete params[name];
    }

    return undefined;
  }

  private toSegments(path: string): string[] {
    return path.split("/").filter((s) => s.length > 0);
  }
}

/**
 * Safely URL-decodes a path segment.
 * Returns the original segment if decoding fails (malformed encoding).
 */
function decodePathSegment(segment: string): string {
  try {
    return decodeURIComponent(segment);
  } catch {
    return segment;
  }
}
