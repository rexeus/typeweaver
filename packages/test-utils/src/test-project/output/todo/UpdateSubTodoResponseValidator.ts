/* eslint-disable */
/**
 * This file was automatically generated by TypeWeaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import definition from "../../definition/todo/mutations/UpdateSubTodoDefinition";
import type { ZodSafeParseResult } from "zod/v4";
import {
  type IHttpResponse,
  type SafeResponseValidationResult,
  ResponseValidationError,
} from "@rexeus/typeweaver-core";
import { ResponseValidator, assert } from "../lib/types";
import {
  type UpdateSubTodoResponse,
  type IUpdateSubTodoSuccessResponse,
  UpdateSubTodoSuccessResponse,
  type IUpdateSubTodoSuccessResponseBody,
  type IUpdateSubTodoSuccessResponseHeader,
} from "./UpdateSubTodoResponse";

import {
  type ISubTodoNotFoundErrorResponse,
  SubTodoNotFoundErrorResponse,
  type ISubTodoNotFoundErrorResponseBody,
  type ISubTodoNotFoundErrorResponseHeader,
} from "./SubTodoNotFoundErrorResponse";

import {
  type ISubTodoNotChangeableErrorResponse,
  SubTodoNotChangeableErrorResponse,
  type ISubTodoNotChangeableErrorResponseBody,
  type ISubTodoNotChangeableErrorResponseHeader,
} from "./SubTodoNotChangeableErrorResponse";

import {
  type ISubTodoStatusTransitionInvalidErrorResponse,
  SubTodoStatusTransitionInvalidErrorResponse,
  type ISubTodoStatusTransitionInvalidErrorResponseBody,
  type ISubTodoStatusTransitionInvalidErrorResponseHeader,
} from "./SubTodoStatusTransitionInvalidErrorResponse";

import {
  type ITodoNotFoundErrorResponse,
  TodoNotFoundErrorResponse,
  type ITodoNotFoundErrorResponseBody,
  type ITodoNotFoundErrorResponseHeader,
} from "./TodoNotFoundErrorResponse";

import {
  type IForbiddenErrorResponse,
  ForbiddenErrorResponse,
  type IForbiddenErrorResponseBody,
  type IForbiddenErrorResponseHeader,
} from "../shared/ForbiddenErrorResponse";

import {
  type IInternalServerErrorResponse,
  InternalServerErrorResponse,
  type IInternalServerErrorResponseBody,
  type IInternalServerErrorResponseHeader,
} from "../shared/InternalServerErrorResponse";

import {
  type ITooManyRequestsErrorResponse,
  TooManyRequestsErrorResponse,
  type ITooManyRequestsErrorResponseBody,
  type ITooManyRequestsErrorResponseHeader,
} from "../shared/TooManyRequestsErrorResponse";

import {
  type IUnauthorizedErrorResponse,
  UnauthorizedErrorResponse,
  type IUnauthorizedErrorResponseBody,
  type IUnauthorizedErrorResponseHeader,
} from "../shared/UnauthorizedErrorResponse";

import {
  type IUnsupportedMediaTypeErrorResponse,
  UnsupportedMediaTypeErrorResponse,
  type IUnsupportedMediaTypeErrorResponseBody,
  type IUnsupportedMediaTypeErrorResponseHeader,
} from "../shared/UnsupportedMediaTypeErrorResponse";

import {
  type IValidationErrorResponse,
  ValidationErrorResponse,
  type IValidationErrorResponseBody,
  type IValidationErrorResponseHeader,
} from "../shared/ValidationErrorResponse";

export class UpdateSubTodoResponseValidator extends ResponseValidator {
  public safeValidate(
    response: IHttpResponse,
  ): SafeResponseValidationResult<UpdateSubTodoResponse> {
    const result = this.validateAgainstDefinedResponses(response);

    if (!result.isValid && !result.error.hasResponseIssues()) {
      result.error.addStatusCodeIssue([
        200, 400, 401, 403, 404, 409, 415, 429, 500,
      ]);
    }

    return result;
  }

  public validate(response: IHttpResponse): UpdateSubTodoResponse {
    const result = this.safeValidate(response);

    if (!result.isValid) {
      throw result.error;
    }

    return result.data;
  }

  private validateAgainstDefinedResponses(
    response: IHttpResponse,
  ): SafeResponseValidationResult<UpdateSubTodoResponse> {
    const error = new ResponseValidationError(response.statusCode);

    if (response.statusCode === 200) {
      const validateUpdateSubTodoSuccessResponseResult =
        this.validateUpdateSubTodoSuccessResponse(response, error);
      if (validateUpdateSubTodoSuccessResponseResult.isValid) {
        return validateUpdateSubTodoSuccessResponseResult;
      }
    }

    if (response.statusCode === 404) {
      const validateSubTodoNotFoundErrorResponseResult =
        this.validateSubTodoNotFoundErrorResponse(response, error);
      if (validateSubTodoNotFoundErrorResponseResult.isValid) {
        return validateSubTodoNotFoundErrorResponseResult;
      }

      const validateTodoNotFoundErrorResponseResult =
        this.validateTodoNotFoundErrorResponse(response, error);
      if (validateTodoNotFoundErrorResponseResult.isValid) {
        return validateTodoNotFoundErrorResponseResult;
      }
    }

    if (response.statusCode === 409) {
      const validateSubTodoNotChangeableErrorResponseResult =
        this.validateSubTodoNotChangeableErrorResponse(response, error);
      if (validateSubTodoNotChangeableErrorResponseResult.isValid) {
        return validateSubTodoNotChangeableErrorResponseResult;
      }

      const validateSubTodoStatusTransitionInvalidErrorResponseResult =
        this.validateSubTodoStatusTransitionInvalidErrorResponse(
          response,
          error,
        );
      if (validateSubTodoStatusTransitionInvalidErrorResponseResult.isValid) {
        return validateSubTodoStatusTransitionInvalidErrorResponseResult;
      }
    }

    if (response.statusCode === 403) {
      const validateForbiddenErrorResponseResult =
        this.validateForbiddenErrorResponse(response, error);
      if (validateForbiddenErrorResponseResult.isValid) {
        return validateForbiddenErrorResponseResult;
      }
    }

    if (response.statusCode === 500) {
      const validateInternalServerErrorResponseResult =
        this.validateInternalServerErrorResponse(response, error);
      if (validateInternalServerErrorResponseResult.isValid) {
        return validateInternalServerErrorResponseResult;
      }
    }

    if (response.statusCode === 429) {
      const validateTooManyRequestsErrorResponseResult =
        this.validateTooManyRequestsErrorResponse(response, error);
      if (validateTooManyRequestsErrorResponseResult.isValid) {
        return validateTooManyRequestsErrorResponseResult;
      }
    }

    if (response.statusCode === 401) {
      const validateUnauthorizedErrorResponseResult =
        this.validateUnauthorizedErrorResponse(response, error);
      if (validateUnauthorizedErrorResponseResult.isValid) {
        return validateUnauthorizedErrorResponseResult;
      }
    }

    if (response.statusCode === 415) {
      const validateUnsupportedMediaTypeErrorResponseResult =
        this.validateUnsupportedMediaTypeErrorResponse(response, error);
      if (validateUnsupportedMediaTypeErrorResponseResult.isValid) {
        return validateUnsupportedMediaTypeErrorResponseResult;
      }
    }

    if (response.statusCode === 400) {
      const validateValidationErrorResponseResult =
        this.validateValidationErrorResponse(response, error);
      if (validateValidationErrorResponseResult.isValid) {
        return validateValidationErrorResponseResult;
      }
    }

    return {
      isValid: false,
      error,
    };
  }

  private validateUpdateSubTodoSuccessResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<UpdateSubTodoSuccessResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[0] &&
        "body" in definition.responses[0] &&
        definition.responses[0].body,
      "'UpdateSubTodoSuccessResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[0].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<IUpdateSubTodoSuccessResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues(
        "UpdateSubTodoSuccess",
        validateBodyResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[0] &&
        "header" in definition.responses[0] &&
        definition.responses[0].header,
      "'UpdateSubTodoSuccessResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[0].header.shape,
    );
    const validateHeaderResult = definition.responses[0].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<IUpdateSubTodoSuccessResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "UpdateSubTodoSuccess",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new UpdateSubTodoSuccessResponse(
        validatedResponse as IUpdateSubTodoSuccessResponse,
      ),
    };
  }

  private validateSubTodoNotFoundErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<SubTodoNotFoundErrorResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[1] &&
        "body" in definition.responses[1] &&
        definition.responses[1].body,
      "'SubTodoNotFoundErrorResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[1].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<ISubTodoNotFoundErrorResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues(
        "SubTodoNotFoundError",
        validateBodyResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[1] &&
        "header" in definition.responses[1] &&
        definition.responses[1].header,
      "'SubTodoNotFoundErrorResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[1].header.shape,
    );
    const validateHeaderResult = definition.responses[1].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<ISubTodoNotFoundErrorResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "SubTodoNotFoundError",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new SubTodoNotFoundErrorResponse(
        validatedResponse as ISubTodoNotFoundErrorResponse,
      ),
    };
  }

  private validateSubTodoNotChangeableErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<SubTodoNotChangeableErrorResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[2] &&
        "body" in definition.responses[2] &&
        definition.responses[2].body,
      "'SubTodoNotChangeableErrorResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[2].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<ISubTodoNotChangeableErrorResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues(
        "SubTodoNotChangeableError",
        validateBodyResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[2] &&
        "header" in definition.responses[2] &&
        definition.responses[2].header,
      "'SubTodoNotChangeableErrorResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[2].header.shape,
    );
    const validateHeaderResult = definition.responses[2].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<ISubTodoNotChangeableErrorResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "SubTodoNotChangeableError",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new SubTodoNotChangeableErrorResponse(
        validatedResponse as ISubTodoNotChangeableErrorResponse,
      ),
    };
  }

  private validateSubTodoStatusTransitionInvalidErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<SubTodoStatusTransitionInvalidErrorResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[3] &&
        "body" in definition.responses[3] &&
        definition.responses[3].body,
      "'SubTodoStatusTransitionInvalidErrorResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[3].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<ISubTodoStatusTransitionInvalidErrorResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues(
        "SubTodoStatusTransitionInvalidError",
        validateBodyResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[3] &&
        "header" in definition.responses[3] &&
        definition.responses[3].header,
      "'SubTodoStatusTransitionInvalidErrorResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[3].header.shape,
    );
    const validateHeaderResult = definition.responses[3].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<ISubTodoStatusTransitionInvalidErrorResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "SubTodoStatusTransitionInvalidError",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new SubTodoStatusTransitionInvalidErrorResponse(
        validatedResponse as ISubTodoStatusTransitionInvalidErrorResponse,
      ),
    };
  }

  private validateTodoNotFoundErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<TodoNotFoundErrorResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[4] &&
        "body" in definition.responses[4] &&
        definition.responses[4].body,
      "'TodoNotFoundErrorResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[4].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<ITodoNotFoundErrorResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues("TodoNotFoundError", validateBodyResult.error.issues);
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[4] &&
        "header" in definition.responses[4] &&
        definition.responses[4].header,
      "'TodoNotFoundErrorResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[4].header.shape,
    );
    const validateHeaderResult = definition.responses[4].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<ITodoNotFoundErrorResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "TodoNotFoundError",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new TodoNotFoundErrorResponse(
        validatedResponse as ITodoNotFoundErrorResponse,
      ),
    };
  }

  private validateForbiddenErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<ForbiddenErrorResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[5] &&
        "body" in definition.responses[5] &&
        definition.responses[5].body,
      "'ForbiddenErrorResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[5].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<IForbiddenErrorResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues("ForbiddenError", validateBodyResult.error.issues);
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[5] &&
        "header" in definition.responses[5] &&
        definition.responses[5].header,
      "'ForbiddenErrorResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[5].header.shape,
    );
    const validateHeaderResult = definition.responses[5].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<IForbiddenErrorResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "ForbiddenError",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new ForbiddenErrorResponse(
        validatedResponse as IForbiddenErrorResponse,
      ),
    };
  }

  private validateInternalServerErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<InternalServerErrorResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[6] &&
        "body" in definition.responses[6] &&
        definition.responses[6].body,
      "'InternalServerErrorResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[6].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<IInternalServerErrorResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues(
        "InternalServerError",
        validateBodyResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[6] &&
        "header" in definition.responses[6] &&
        definition.responses[6].header,
      "'InternalServerErrorResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[6].header.shape,
    );
    const validateHeaderResult = definition.responses[6].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<IInternalServerErrorResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "InternalServerError",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new InternalServerErrorResponse(
        validatedResponse as IInternalServerErrorResponse,
      ),
    };
  }

  private validateTooManyRequestsErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<TooManyRequestsErrorResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[7] &&
        "body" in definition.responses[7] &&
        definition.responses[7].body,
      "'TooManyRequestsErrorResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[7].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<ITooManyRequestsErrorResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues(
        "TooManyRequestsError",
        validateBodyResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[7] &&
        "header" in definition.responses[7] &&
        definition.responses[7].header,
      "'TooManyRequestsErrorResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[7].header.shape,
    );
    const validateHeaderResult = definition.responses[7].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<ITooManyRequestsErrorResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "TooManyRequestsError",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new TooManyRequestsErrorResponse(
        validatedResponse as ITooManyRequestsErrorResponse,
      ),
    };
  }

  private validateUnauthorizedErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<UnauthorizedErrorResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[8] &&
        "body" in definition.responses[8] &&
        definition.responses[8].body,
      "'UnauthorizedErrorResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[8].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<IUnauthorizedErrorResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues("UnauthorizedError", validateBodyResult.error.issues);
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[8] &&
        "header" in definition.responses[8] &&
        definition.responses[8].header,
      "'UnauthorizedErrorResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[8].header.shape,
    );
    const validateHeaderResult = definition.responses[8].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<IUnauthorizedErrorResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "UnauthorizedError",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new UnauthorizedErrorResponse(
        validatedResponse as IUnauthorizedErrorResponse,
      ),
    };
  }

  private validateUnsupportedMediaTypeErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<UnsupportedMediaTypeErrorResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[9] &&
        "body" in definition.responses[9] &&
        definition.responses[9].body,
      "'UnsupportedMediaTypeErrorResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[9].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<IUnsupportedMediaTypeErrorResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues(
        "UnsupportedMediaTypeError",
        validateBodyResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[9] &&
        "header" in definition.responses[9] &&
        definition.responses[9].header,
      "'UnsupportedMediaTypeErrorResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[9].header.shape,
    );
    const validateHeaderResult = definition.responses[9].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<IUnsupportedMediaTypeErrorResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "UnsupportedMediaTypeError",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new UnsupportedMediaTypeErrorResponse(
        validatedResponse as IUnsupportedMediaTypeErrorResponse,
      ),
    };
  }

  private validateValidationErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<ValidationErrorResponse> {
    let isValid = true;
    const validatedResponse: IHttpResponse = {
      statusCode: response.statusCode,
      header: undefined,
      body: undefined,
    };

    assert(
      definition.responses[10] &&
        "body" in definition.responses[10] &&
        definition.responses[10].body,
      "'ValidationErrorResponseBody' has to be defined in the definition",
    );
    const validateBodyResult = definition.responses[10].body.safeParse(
      response.body,
    ) as unknown as ZodSafeParseResult<IValidationErrorResponseBody>;

    if (!validateBodyResult.success) {
      error.addBodyIssues("ValidationError", validateBodyResult.error.issues);
      isValid = false;
    } else {
      validatedResponse.body = validateBodyResult.data;
    }

    assert(
      definition.responses[10] &&
        "header" in definition.responses[10] &&
        definition.responses[10].header,
      "'ValidationErrorResponseHeader' has to be defined in the definition",
    );
    const coercedHeader = this.coerceHeaderToSchema(
      response.header,
      definition.responses[10].header.shape,
    );
    const validateHeaderResult = definition.responses[10].header.safeParse(
      coercedHeader,
    ) as unknown as ZodSafeParseResult<IValidationErrorResponseHeader>;

    if (!validateHeaderResult.success) {
      error.addHeaderIssues(
        "ValidationError",
        validateHeaderResult.error.issues,
      );
      isValid = false;
    } else {
      validatedResponse.header = validateHeaderResult.data;
    }

    if (!isValid) {
      return { isValid: false, error };
    }

    return {
      isValid: true,
      data: new ValidationErrorResponse(
        validatedResponse as IValidationErrorResponse,
      ),
    };
  }
}
