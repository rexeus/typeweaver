/* eslint-disable */
/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import definition from "../definition/todo/mutations/UpdateTodoStatusDefinition";
import type { ZodSafeParseResult } from "zod";
import {
  type IHttpResponse,
  type SafeResponseValidationResult,
  ResponseValidationError,
} from "@rexeus/typeweaver-core";
import { ResponseValidator } from "../lib/types";
import {
  type UpdateTodoStatusResponse,
  type IUpdateTodoStatusSuccessResponse,
  UpdateTodoStatusSuccessResponse,
} from "./UpdateTodoStatusResponse";

import {
  type ITodoNotFoundErrorResponse,
  TodoNotFoundErrorResponse,
} from "./TodoNotFoundErrorResponse";

import {
  type ITodoStatusTransitionInvalidErrorResponse,
  TodoStatusTransitionInvalidErrorResponse,
} from "./TodoStatusTransitionInvalidErrorResponse";

import {
  type ITodoNotChangeableErrorResponse,
  TodoNotChangeableErrorResponse,
} from "./TodoNotChangeableErrorResponse";

import {
  type IForbiddenErrorResponse,
  ForbiddenErrorResponse,
} from "../shared/ForbiddenErrorResponse";

import {
  type IInternalServerErrorResponse,
  InternalServerErrorResponse,
} from "../shared/InternalServerErrorResponse";

import {
  type ITooManyRequestsErrorResponse,
  TooManyRequestsErrorResponse,
} from "../shared/TooManyRequestsErrorResponse";

import {
  type IUnauthorizedErrorResponse,
  UnauthorizedErrorResponse,
} from "../shared/UnauthorizedErrorResponse";

import {
  type IUnsupportedMediaTypeErrorResponse,
  UnsupportedMediaTypeErrorResponse,
} from "../shared/UnsupportedMediaTypeErrorResponse";

import {
  type IValidationErrorResponse,
  ValidationErrorResponse,
} from "../shared/ValidationErrorResponse";

export class UpdateTodoStatusResponseValidator extends ResponseValidator {
  public safeValidate(
    response: IHttpResponse,
  ): SafeResponseValidationResult<UpdateTodoStatusResponse> {
    const result = this.validateAgainstDefinedResponses(response);

    if (!result.isValid && !result.error.hasResponseIssues()) {
      result.error.addStatusCodeIssue([
        200, 400, 401, 403, 404, 409, 415, 429, 500,
      ]);
    }

    return result;
  }

  public validate(response: IHttpResponse): UpdateTodoStatusResponse {
    const result = this.safeValidate(response);

    if (!result.isValid) {
      throw result.error;
    }

    return result.data;
  }

  private validateAgainstDefinedResponses(
    response: IHttpResponse,
  ): SafeResponseValidationResult<UpdateTodoStatusResponse> {
    const error = new ResponseValidationError(response.statusCode);

    if (response.statusCode === 200) {
      const validateUpdateTodoStatusSuccessResponseResult =
        this.validateUpdateTodoStatusSuccessResponse(response, error);
      if (validateUpdateTodoStatusSuccessResponseResult.isValid) {
        return validateUpdateTodoStatusSuccessResponseResult;
      }
    }

    if (response.statusCode === 404) {
      const validateTodoNotFoundErrorResponseResult =
        this.validateTodoNotFoundErrorResponse(response, error);
      if (validateTodoNotFoundErrorResponseResult.isValid) {
        return validateTodoNotFoundErrorResponseResult;
      }
    }

    if (response.statusCode === 409) {
      const validateTodoStatusTransitionInvalidErrorResponseResult =
        this.validateTodoStatusTransitionInvalidErrorResponse(response, error);
      if (validateTodoStatusTransitionInvalidErrorResponseResult.isValid) {
        return validateTodoStatusTransitionInvalidErrorResponseResult;
      }

      const validateTodoNotChangeableErrorResponseResult =
        this.validateTodoNotChangeableErrorResponse(response, error);
      if (validateTodoNotChangeableErrorResponseResult.isValid) {
        return validateTodoNotChangeableErrorResponseResult;
      }
    }

    if (response.statusCode === 403) {
      const validateForbiddenErrorResponseResult =
        this.validateForbiddenErrorResponse(response, error);
      if (validateForbiddenErrorResponseResult.isValid) {
        return validateForbiddenErrorResponseResult;
      }
    }

    if (response.statusCode === 500) {
      const validateInternalServerErrorResponseResult =
        this.validateInternalServerErrorResponse(response, error);
      if (validateInternalServerErrorResponseResult.isValid) {
        return validateInternalServerErrorResponseResult;
      }
    }

    if (response.statusCode === 429) {
      const validateTooManyRequestsErrorResponseResult =
        this.validateTooManyRequestsErrorResponse(response, error);
      if (validateTooManyRequestsErrorResponseResult.isValid) {
        return validateTooManyRequestsErrorResponseResult;
      }
    }

    if (response.statusCode === 401) {
      const validateUnauthorizedErrorResponseResult =
        this.validateUnauthorizedErrorResponse(response, error);
      if (validateUnauthorizedErrorResponseResult.isValid) {
        return validateUnauthorizedErrorResponseResult;
      }
    }

    if (response.statusCode === 415) {
      const validateUnsupportedMediaTypeErrorResponseResult =
        this.validateUnsupportedMediaTypeErrorResponse(response, error);
      if (validateUnsupportedMediaTypeErrorResponseResult.isValid) {
        return validateUnsupportedMediaTypeErrorResponseResult;
      }
    }

    if (response.statusCode === 400) {
      const validateValidationErrorResponseResult =
        this.validateValidationErrorResponse(response, error);
      if (validateValidationErrorResponseResult.isValid) {
        return validateValidationErrorResponseResult;
      }
    }

    return {
      isValid: false,
      error,
    };
  }

  private validateUpdateTodoStatusSuccessResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<UpdateTodoStatusSuccessResponse> {
    const result = this.validateResponseType<UpdateTodoStatusSuccessResponse>(
      "UpdateTodoStatusSuccess",
      definition.responses[0] && "header" in definition.responses[0]
        ? definition.responses[0]!.header
        : undefined,
      definition.responses[0] && "body" in definition.responses[0]
        ? definition.responses[0]!.body
        : undefined,
    )(response, error);

    if (!result.isValid) {
      return result;
    }

    return {
      isValid: true,
      data: new UpdateTodoStatusSuccessResponse(
        result.data as IUpdateTodoStatusSuccessResponse,
      ),
    };
  }

  private validateTodoNotFoundErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<TodoNotFoundErrorResponse> {
    const result = this.validateResponseType<TodoNotFoundErrorResponse>(
      "TodoNotFoundError",
      definition.responses[1] && "header" in definition.responses[1]
        ? definition.responses[1]!.header
        : undefined,
      definition.responses[1] && "body" in definition.responses[1]
        ? definition.responses[1]!.body
        : undefined,
    )(response, error);

    if (!result.isValid) {
      return result;
    }

    return {
      isValid: true,
      data: new TodoNotFoundErrorResponse(
        result.data as ITodoNotFoundErrorResponse,
      ),
    };
  }

  private validateTodoStatusTransitionInvalidErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<TodoStatusTransitionInvalidErrorResponse> {
    const result =
      this.validateResponseType<TodoStatusTransitionInvalidErrorResponse>(
        "TodoStatusTransitionInvalidError",
        definition.responses[2] && "header" in definition.responses[2]
          ? definition.responses[2]!.header
          : undefined,
        definition.responses[2] && "body" in definition.responses[2]
          ? definition.responses[2]!.body
          : undefined,
      )(response, error);

    if (!result.isValid) {
      return result;
    }

    return {
      isValid: true,
      data: new TodoStatusTransitionInvalidErrorResponse(
        result.data as ITodoStatusTransitionInvalidErrorResponse,
      ),
    };
  }

  private validateTodoNotChangeableErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<TodoNotChangeableErrorResponse> {
    const result = this.validateResponseType<TodoNotChangeableErrorResponse>(
      "TodoNotChangeableError",
      definition.responses[3] && "header" in definition.responses[3]
        ? definition.responses[3]!.header
        : undefined,
      definition.responses[3] && "body" in definition.responses[3]
        ? definition.responses[3]!.body
        : undefined,
    )(response, error);

    if (!result.isValid) {
      return result;
    }

    return {
      isValid: true,
      data: new TodoNotChangeableErrorResponse(
        result.data as ITodoNotChangeableErrorResponse,
      ),
    };
  }

  private validateForbiddenErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<ForbiddenErrorResponse> {
    const result = this.validateResponseType<ForbiddenErrorResponse>(
      "ForbiddenError",
      definition.responses[4] && "header" in definition.responses[4]
        ? definition.responses[4]!.header
        : undefined,
      definition.responses[4] && "body" in definition.responses[4]
        ? definition.responses[4]!.body
        : undefined,
    )(response, error);

    if (!result.isValid) {
      return result;
    }

    return {
      isValid: true,
      data: new ForbiddenErrorResponse(result.data as IForbiddenErrorResponse),
    };
  }

  private validateInternalServerErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<InternalServerErrorResponse> {
    const result = this.validateResponseType<InternalServerErrorResponse>(
      "InternalServerError",
      definition.responses[5] && "header" in definition.responses[5]
        ? definition.responses[5]!.header
        : undefined,
      definition.responses[5] && "body" in definition.responses[5]
        ? definition.responses[5]!.body
        : undefined,
    )(response, error);

    if (!result.isValid) {
      return result;
    }

    return {
      isValid: true,
      data: new InternalServerErrorResponse(
        result.data as IInternalServerErrorResponse,
      ),
    };
  }

  private validateTooManyRequestsErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<TooManyRequestsErrorResponse> {
    const result = this.validateResponseType<TooManyRequestsErrorResponse>(
      "TooManyRequestsError",
      definition.responses[6] && "header" in definition.responses[6]
        ? definition.responses[6]!.header
        : undefined,
      definition.responses[6] && "body" in definition.responses[6]
        ? definition.responses[6]!.body
        : undefined,
    )(response, error);

    if (!result.isValid) {
      return result;
    }

    return {
      isValid: true,
      data: new TooManyRequestsErrorResponse(
        result.data as ITooManyRequestsErrorResponse,
      ),
    };
  }

  private validateUnauthorizedErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<UnauthorizedErrorResponse> {
    const result = this.validateResponseType<UnauthorizedErrorResponse>(
      "UnauthorizedError",
      definition.responses[7] && "header" in definition.responses[7]
        ? definition.responses[7]!.header
        : undefined,
      definition.responses[7] && "body" in definition.responses[7]
        ? definition.responses[7]!.body
        : undefined,
    )(response, error);

    if (!result.isValid) {
      return result;
    }

    return {
      isValid: true,
      data: new UnauthorizedErrorResponse(
        result.data as IUnauthorizedErrorResponse,
      ),
    };
  }

  private validateUnsupportedMediaTypeErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<UnsupportedMediaTypeErrorResponse> {
    const result = this.validateResponseType<UnsupportedMediaTypeErrorResponse>(
      "UnsupportedMediaTypeError",
      definition.responses[8] && "header" in definition.responses[8]
        ? definition.responses[8]!.header
        : undefined,
      definition.responses[8] && "body" in definition.responses[8]
        ? definition.responses[8]!.body
        : undefined,
    )(response, error);

    if (!result.isValid) {
      return result;
    }

    return {
      isValid: true,
      data: new UnsupportedMediaTypeErrorResponse(
        result.data as IUnsupportedMediaTypeErrorResponse,
      ),
    };
  }

  private validateValidationErrorResponse(
    response: IHttpResponse,
    error: ResponseValidationError,
  ): SafeResponseValidationResult<ValidationErrorResponse> {
    const result = this.validateResponseType<ValidationErrorResponse>(
      "ValidationError",
      definition.responses[9] && "header" in definition.responses[9]
        ? definition.responses[9]!.header
        : undefined,
      definition.responses[9] && "body" in definition.responses[9]
        ? definition.responses[9]!.body
        : undefined,
    )(response, error);

    if (!result.isValid) {
      return result;
    }

    return {
      isValid: true,
      data: new ValidationErrorResponse(
        result.data as IValidationErrorResponse,
      ),
    };
  }
}
