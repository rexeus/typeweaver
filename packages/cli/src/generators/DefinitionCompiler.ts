import fs from "node:fs";
import path from "node:path";
import { transformSync } from "oxc-transform";
import { DefinitionCompilationError } from "./errors/DefinitionCompilationError.js";

/**
 * Compiles TypeScript definition files to JavaScript + declaration stubs.
 *
 * Definition files contain Zod schemas that cause tsc to exhaust memory
 * when type-checking due to Zod v4's deeply recursive type inference.
 * By pre-compiling definitions to .js + .d.ts, tsc only sees lightweight
 * type stubs (everything typed as `any`) while runtime behavior is preserved.
 */
export class DefinitionCompiler {
  /**
   * Compiles all .ts definition files in-place to .js + .d.ts stubs.
   * The original .ts files are removed after compilation.
   */
  public compileInPlace(definitionDir: string): void {
    const errors: DefinitionCompilationError[] = [];
    this.processDirectory(definitionDir, errors);

    if (errors.length > 0) {
      const summary = errors
        .map(e => `  - ${e.filePath}: ${e.details}`)
        .join("\n");

      throw new DefinitionCompilationError(
        definitionDir,
        `${errors.length} file(s) failed to compile:\n${summary}`
      );
    }
  }

  private processDirectory(
    dir: string,
    errors: DefinitionCompilationError[]
  ): void {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        this.processDirectory(fullPath, errors);
        continue;
      }

      if (
        entry.isFile() &&
        entry.name.endsWith(".ts") &&
        !entry.name.endsWith(".d.ts")
      ) {
        try {
          this.compileFile(fullPath, dir, entry.name);
        } catch (error) {
          errors.push(
            error instanceof DefinitionCompilationError
              ? error
              : new DefinitionCompilationError(fullPath, String(error))
          );
        }
      }
    }
  }

  private compileFile(srcPath: string, dir: string, fileName: string): void {
    try {
      const source = fs.readFileSync(srcPath, "utf-8");
      const baseName = fileName.replace(/\.ts$/, "");

      const jsCode = this.transpileToJs(fileName, source);
      const dtsCode = this.generateDtsStub(source);

      fs.writeFileSync(path.join(dir, `${baseName}.js`), jsCode);
      fs.writeFileSync(path.join(dir, `${baseName}.d.ts`), dtsCode);
      fs.unlinkSync(srcPath);
    } catch (error) {
      throw new DefinitionCompilationError(
        srcPath,
        error instanceof DefinitionCompilationError
          ? error.details
          : error instanceof Error
            ? error.message
            : String(error)
      );
    }
  }

  private transpileToJs(fileName: string, source: string): string {
    const result = transformSync(fileName, source, {
      lang: "ts",
      sourceType: "module",
    });

    const errors = result.errors.filter(e => e.severity === "Error");
    if (errors.length > 0) {
      const messages = errors.map(e => e.message).join("; ");
      throw new DefinitionCompilationError(fileName, messages);
    }

    return result.code;
  }

  /**
   * Generates a minimal .d.ts stub from TypeScript source.
   * All value exports are typed as `any` to avoid pulling in Zod's type system.
   * Re-exports are preserved so barrel files chain correctly.
   */
  private generateDtsStub(source: string): string {
    if (source.includes("@generated by @rexeus/typeweaver")) {
      return source;
    }

    const lines: string[] = [
      "/* eslint-disable */",
      "/**",
      " * This file was automatically generated by typeweaver.",
      " * DO NOT EDIT. Instead, modify the source definition file and generate again.",
      " *",
      " * @generated by @rexeus/typeweaver",
      " */",
    ];
    let hasDefaultExport = false;
    let pastLeadingComments = false;

    for (const line of source.split("\n")) {
      const trimmed = line.trim();

      if (!pastLeadingComments) {
        if (
          trimmed.startsWith("/*") ||
          trimmed.startsWith("//") ||
          trimmed.startsWith("*") ||
          trimmed === ""
        ) {
          if (trimmed !== "" && !trimmed.includes("@generated")) {
            lines.push(trimmed);
          }
          continue;
        }
        pastLeadingComments = true;
      }

      if (trimmed.startsWith("export {") || trimmed.startsWith("export *")) {
        lines.push(trimmed);
        continue;
      }

      if (trimmed.startsWith("export default") && !hasDefaultExport) {
        lines.push("declare const _default: any;");
        lines.push("export default _default;");
        hasDefaultExport = true;
        continue;
      }

      const constMatch = trimmed.match(/^export\s+(?:const|let|var)\s+(\w+)/);
      if (constMatch) {
        lines.push(`export declare const ${constMatch[1]}: any;`);
        continue;
      }

      const funcMatch = trimmed.match(
        /^export\s+(?:async\s+)?function\s*\*?\s+(\w+)/
      );
      if (funcMatch) {
        lines.push(
          `export declare function ${funcMatch[1]}(...args: any[]): any;`
        );
        continue;
      }

      if (
        trimmed.startsWith("export") &&
        !trimmed.startsWith("export {") &&
        !trimmed.startsWith("export *") &&
        !trimmed.startsWith("export default") &&
        !trimmed.startsWith("export type")
      ) {
        console.warn(
          `[DefinitionCompiler] Unrecognized export pattern in definition stub: ${trimmed}`
        );
      }
    }

    return lines.join("\n") + "\n";
  }
}
