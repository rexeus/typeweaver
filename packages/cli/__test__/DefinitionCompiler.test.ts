import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import { afterEach, beforeEach, describe, expect, test, vi } from "vitest";
import { DefinitionCompiler } from "../src/generators/DefinitionCompiler.js";
import { DefinitionCompilationError } from "../src/generators/errors/DefinitionCompilationError.js";

const compiler = new DefinitionCompiler();

const GENERATED_HEADER = [
  "/* eslint-disable */",
  "/**",
  " * This file was automatically generated by typeweaver.",
  " * DO NOT EDIT. Instead, modify the source definition file and generate again.",
  " *",
  " * @generated by @rexeus/typeweaver",
  " */",
].join("\n");

// Access private methods for unit testing
const transpileToJs = (fileName: string, source: string): string =>
  (compiler as any).transpileToJs(fileName, source);

const generateDtsStub = (source: string): string =>
  (compiler as any).generateDtsStub(source);

describe("DefinitionCompiler", () => {
  describe("transpileToJs", () => {
    test("strips type annotations from valid TypeScript", () => {
      const result = transpileToJs(
        "test.ts",
        'export const foo: string = "bar";'
      );
      expect(result).toContain("export const foo =");
      expect(result).not.toContain(": string");
    });

    test("throws DefinitionCompilationError for invalid syntax", () => {
      expect(() => transpileToJs("broken.ts", "export const = ;")).toThrow(
        DefinitionCompilationError
      );
    });
  });

  describe("generateDtsStub", () => {
    test("starts with standard generated header", () => {
      const result = generateDtsStub('export const x = 1;');
      expect(result).toMatch(/^\/\* eslint-disable \*\//);
      expect(result).toContain("@generated by @rexeus/typeweaver");
    });

    test("converts export const to declare const with any type", () => {
      const result = generateDtsStub(
        'export const todoSchema = z.object({ name: z.string() });'
      );
      expect(result).toBe(
        `${GENERATED_HEADER}\nexport declare const todoSchema: any;\n`
      );
    });

    test("converts export default to declare const _default", () => {
      const result = generateDtsStub(
        "export default new HttpOperationDefinition({});"
      );
      expect(result).toBe(
        `${GENERATED_HEADER}\ndeclare const _default: any;\nexport default _default;\n`
      );
    });

    test("converts export function to declare function", () => {
      const result = generateDtsStub(
        "export function listResponseSchema(schema) { return schema; }"
      );
      expect(result).toBe(
        `${GENERATED_HEADER}\nexport declare function listResponseSchema(...args: any[]): any;\n`
      );
    });

    test("converts export async function to declare function", () => {
      const result = generateDtsStub(
        "export async function fetchData(url) { return fetch(url); }"
      );
      expect(result).toBe(
        `${GENERATED_HEADER}\nexport declare function fetchData(...args: any[]): any;\n`
      );
    });

    test("preserves export * re-exports", () => {
      const result = generateDtsStub(
        'export * from "./schemas/metadataSchema";'
      );
      expect(result).toBe(
        `${GENERATED_HEADER}\nexport * from "./schemas/metadataSchema";\n`
      );
    });

    test("preserves export { default as } re-exports", () => {
      const result = generateDtsStub(
        'export { default as FooDefinition } from "./Foo";'
      );
      expect(result).toBe(
        `${GENERATED_HEADER}\nexport { default as FooDefinition } from "./Foo";\n`
      );
    });

    test("preserves leading comments before first export", () => {
      const source = [
        "/* oxlint-disable import/max-dependencies */",
        'export * from "./todoSchema";',
        'export { default as Foo } from "./Foo";',
      ].join("\n");
      const result = generateDtsStub(source);
      expect(result).toBe(
        [
          GENERATED_HEADER,
          "/* oxlint-disable import/max-dependencies */",
          'export * from "./todoSchema";',
          'export { default as Foo } from "./Foo";',
          "",
        ].join("\n")
      );
    });

    test("does not duplicate @generated header from source", () => {
      const source = [
        "// @generated by something",
        'export const x = 1;',
      ].join("\n");
      const result = generateDtsStub(source);
      expect(result).toBe(
        `${GENERATED_HEADER}\nexport declare const x: any;\n`
      );
    });

    test("ignores non-export lines", () => {
      const source = [
        'import { z } from "zod";',
        "",
        "// A comment",
        'const internal = "hidden";',
        'export const visible = "shown";',
      ].join("\n");
      const result = generateDtsStub(source);
      expect(result).toBe(
        `${GENERATED_HEADER}\nexport declare const visible: any;\n`
      );
    });

    test("only includes the first default export", () => {
      const source = [
        "export default firstThing;",
        "export default secondThing;",
      ].join("\n");
      const result = generateDtsStub(source);
      expect(result).toBe(
        `${GENERATED_HEADER}\ndeclare const _default: any;\nexport default _default;\n`
      );
    });

    test("returns source unchanged when already @generated (idempotency)", () => {
      const alreadyGenerated = [
        GENERATED_HEADER,
        "export declare const foo: any;",
        "",
      ].join("\n");
      const result = generateDtsStub(alreadyGenerated);
      expect(result).toBe(alreadyGenerated);
    });

    test("handles generator functions (function*)", () => {
      const result = generateDtsStub(
        "export function* idGenerator() { yield 1; }"
      );
      expect(result).toBe(
        `${GENERATED_HEADER}\nexport declare function idGenerator(...args: any[]): any;\n`
      );
    });

    test("handles async generator functions (async function*)", () => {
      const result = generateDtsStub(
        "export async function* streamData() { yield 1; }"
      );
      expect(result).toBe(
        `${GENERATED_HEADER}\nexport declare function streamData(...args: any[]): any;\n`
      );
    });

    test("warns on unrecognized export patterns", () => {
      const warnSpy = vi.spyOn(console, "warn").mockImplementation(() => {});

      generateDtsStub("export class Foo {}");

      expect(warnSpy).toHaveBeenCalledWith(
        expect.stringContaining("Unrecognized export pattern")
      );
      expect(warnSpy).toHaveBeenCalledWith(
        expect.stringContaining("export class Foo {}")
      );

      warnSpy.mockRestore();
    });

    test("does not warn on export type statements", () => {
      const warnSpy = vi.spyOn(console, "warn").mockImplementation(() => {});

      generateDtsStub("export type Foo = { bar: string };");

      expect(warnSpy).not.toHaveBeenCalled();

      warnSpy.mockRestore();
    });
  });

  describe("compileInPlace", () => {
    let tmpDir: string;

    beforeEach(() => {
      tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "defcomp-"));
    });

    afterEach(() => {
      fs.rmSync(tmpDir, { recursive: true, force: true });
    });

    test("compiles .ts to .js + .d.ts and removes original", () => {
      fs.writeFileSync(
        path.join(tmpDir, "foo.ts"),
        'export const foo: string = "bar";'
      );

      compiler.compileInPlace(tmpDir);

      expect(fs.existsSync(path.join(tmpDir, "foo.ts"))).toBe(false);
      expect(fs.existsSync(path.join(tmpDir, "foo.js"))).toBe(true);
      expect(fs.existsSync(path.join(tmpDir, "foo.d.ts"))).toBe(true);
    });

    test("skips existing .d.ts files", () => {
      const dtsPath = path.join(tmpDir, "types.d.ts");
      fs.writeFileSync(dtsPath, "export declare const x: number;");

      compiler.compileInPlace(tmpDir);

      expect(fs.existsSync(dtsPath)).toBe(true);
      expect(fs.readFileSync(dtsPath, "utf-8")).toBe(
        "export declare const x: number;"
      );
    });

    test("processes nested directories recursively", () => {
      const subDir = path.join(tmpDir, "nested");
      fs.mkdirSync(subDir);
      fs.writeFileSync(
        path.join(subDir, "deep.ts"),
        'export const deep: boolean = true;'
      );

      compiler.compileInPlace(tmpDir);

      expect(fs.existsSync(path.join(subDir, "deep.ts"))).toBe(false);
      expect(fs.existsSync(path.join(subDir, "deep.js"))).toBe(true);
      expect(fs.existsSync(path.join(subDir, "deep.d.ts"))).toBe(true);
    });

    test("throws DefinitionCompilationError for invalid files", () => {
      fs.writeFileSync(
        path.join(tmpDir, "broken.ts"),
        "export const = ;"
      );

      expect(() => compiler.compileInPlace(tmpDir)).toThrow(
        DefinitionCompilationError
      );
    });

    test("continues processing after errors and reports all failures", () => {
      fs.writeFileSync(
        path.join(tmpDir, "a_valid.ts"),
        'export const a: string = "ok";'
      );
      fs.writeFileSync(
        path.join(tmpDir, "b_broken.ts"),
        "export const = ;"
      );
      fs.writeFileSync(
        path.join(tmpDir, "c_valid.ts"),
        'export const c: number = 42;'
      );

      try {
        compiler.compileInPlace(tmpDir);
        expect.unreachable("should have thrown");
      } catch (error) {
        expect(error).toBeInstanceOf(DefinitionCompilationError);
        const compError = error as DefinitionCompilationError;
        expect(compError.details).toContain("1 file(s) failed to compile");
      }

      // Valid files should still have been compiled
      expect(fs.existsSync(path.join(tmpDir, "a_valid.js"))).toBe(true);
      expect(fs.existsSync(path.join(tmpDir, "c_valid.js"))).toBe(true);
    });
  });
});
