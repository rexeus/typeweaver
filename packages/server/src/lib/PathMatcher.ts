/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

/**
 * Creates a predicate that tests whether a request path matches a pattern.
 *
 * Supports three pattern types:
 * - **Exact match**: `"/users"` matches only `"/users"`
 * - **Prefix match**: `"/users/*"` matches `"/users"` and any path beneath it
 *   (e.g. `"/users/123"`, `"/users/123/posts"`)
 * - **Parameterized segments**: `"/users/:id"` matches paths where `:id` stands
 *   for exactly one segment (e.g. `"/users/123"` but not `"/users/123/posts"`)
 *
 * Uses the same `:paramName` syntax as typeweaver route definitions.
 *
 * @example
 * ```typescript
 * const isUsersPath = pathMatcher("/users/*");
 * const isUserDetail = pathMatcher("/users/:id");
 *
 * const usersGuard = defineMiddleware(async (ctx, next) => {
 *   if (!isUsersPath(ctx.request.path)) return next();
 *   // guard logic...
 *   return next();
 * });
 * ```
 */
export function pathMatcher(pattern: string): (path: string) => boolean {
  if (pattern.endsWith("/*")) {
    const prefix = pattern.slice(0, -2);
    return path => path === prefix || path.startsWith(prefix + "/");
  }

  const segments = pattern.split("/");
  const hasParams = segments.some(s => s.startsWith(":"));

  if (!hasParams) {
    return path => path === pattern;
  }

  const segmentCount = segments.length;
  const matchers = segments.map(s => (s.startsWith(":") ? null : s));

  return path => {
    const parts = path.split("/");
    if (parts.length !== segmentCount) return false;
    for (let i = 0; i < segmentCount; i++) {
      if (matchers[i] !== null && matchers[i] !== parts[i]) return false;
    }
    return true;
  };
}
