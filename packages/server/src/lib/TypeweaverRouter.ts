/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import {
  HttpResponse,
  RequestValidationError,
} from "@rexeus/typeweaver-core";
import type {
  HttpMethod,
  IHttpRequest,
  IHttpResponse,
  IRequestValidator,
} from "@rexeus/typeweaver-core";
import type { RequestHandler } from "./RequestHandler";

/**
 * A registered route entry with its pattern, validator, and handler.
 */
type Route = {
  method: HttpMethod;
  pattern: RoutePattern;
  validator: IRequestValidator;
  handler: RequestHandler<IHttpRequest, IHttpResponse>;
};

/**
 * A parsed route pattern for matching incoming request paths.
 */
type RoutePattern = {
  /** The original path pattern (e.g., "/todos/:todoId") */
  source: string;
  /** Parsed path segments */
  segments: RouteSegment[];
};

/**
 * A single path segment — either a literal string or a named parameter.
 */
type RouteSegment =
  | { type: "literal"; value: string }
  | { type: "param"; name: string };

/**
 * Result of matching a request path against a route pattern.
 */
type RouteMatch = {
  route: Route;
  params: Record<string, string>;
};

/**
 * Handles HTTP response errors thrown by request handlers.
 * @param error - The HTTP response error that was thrown
 * @param request - The original request
 * @returns The HTTP response to send to the client
 */
export type HttpResponseErrorHandler = (
  error: HttpResponse,
  request: IHttpRequest
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Handles request validation errors.
 * @param error - The validation error containing field-specific issues
 * @param request - The original request
 * @returns The HTTP response to send to the client
 */
export type ValidationErrorHandler = (
  error: RequestValidationError,
  request: IHttpRequest
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Handles any unknown errors not caught by other handlers.
 * @param error - The unknown error (could be anything)
 * @param request - The original request
 * @returns The HTTP response to send to the client
 */
export type UnknownErrorHandler = (
  error: unknown,
  request: IHttpRequest
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Configuration options for TypeweaverRouter.
 * @template TRequestHandlers - Type containing all request handler methods
 */
export type TypeweaverRouterOptions<TRequestHandlers> = {
  /**
   * Request handler methods for each operation.
   * Each handler receives a validated IHttpRequest and returns an IHttpResponse.
   */
  requestHandlers: TRequestHandlers;

  /**
   * Enable request validation using generated validators.
   * When false, requests are passed through without validation.
   * @default true
   */
  validateRequests?: boolean;

  /**
   * Configure handling of HttpResponse errors thrown by handlers.
   * - `true`: Use default handler (returns the error as-is)
   * - `false`: Let errors propagate
   * - `function`: Use custom error handler
   * @default true
   */
  handleHttpResponseErrors?: HttpResponseErrorHandler | boolean;

  /**
   * Configure handling of request validation errors.
   * - `true`: Use default handler (400 with error details)
   * - `false`: Let errors propagate
   * - `function`: Use custom error handler
   * @default true
   */
  handleValidationErrors?: ValidationErrorHandler | boolean;

  /**
   * Configure handling of unknown errors.
   * - `true`: Use default handler (500 Internal Server Error)
   * - `false`: Let errors propagate
   * - `function`: Use custom error handler
   * @default true
   */
  handleUnknownErrors?: UnknownErrorHandler | boolean;
};

/**
 * Abstract base class for typeweaver-generated routers.
 *
 * Works directly with TypeWeaver's IHttpRequest/IHttpResponse — no adapters,
 * no framework context, no mapping layers.
 *
 * Features:
 * - Built-in URL pattern matching with `:param` support
 * - Automatic request validation via generated validators
 * - Configurable error handling (validation, HTTP, unknown)
 * - Zero external dependencies
 *
 * @template TRequestHandlers - Object containing typed request handler methods
 */
export abstract class TypeweaverRouter<TRequestHandlers> {
  protected readonly requestHandlers: TRequestHandlers;

  private readonly routes: Route[] = [];

  private readonly config: {
    validateRequests: boolean;
    errorHandlers: {
      validation: ValidationErrorHandler | undefined;
      httpResponse: HttpResponseErrorHandler | undefined;
      unknown: UnknownErrorHandler | undefined;
    };
  };

  private readonly defaultHandlers = {
    validation: (error: RequestValidationError): IHttpResponse => ({
      statusCode: 400,
      body: {
        code: "VALIDATION_ERROR",
        message: error.message,
        issues: {
          header: error.headerIssues,
          body: error.bodyIssues,
          query: error.queryIssues,
          param: error.pathParamIssues,
        },
      },
    }),

    httpResponse: (error: HttpResponse): IHttpResponse => error,

    unknown: (): IHttpResponse => ({
      statusCode: 500,
      body: {
        code: "INTERNAL_SERVER_ERROR",
        message: "An unexpected error occurred.",
      },
    }),
  };

  public constructor(options: TypeweaverRouterOptions<TRequestHandlers>) {
    const {
      requestHandlers,
      validateRequests = true,
      handleHttpResponseErrors,
      handleValidationErrors,
      handleUnknownErrors,
    } = options;

    this.requestHandlers = requestHandlers;

    this.config = {
      validateRequests,
      errorHandlers: {
        validation: this.resolveErrorHandler(
          handleValidationErrors,
          error => this.defaultHandlers.validation(error)
        ),
        httpResponse: this.resolveErrorHandler(
          handleHttpResponseErrors,
          error => this.defaultHandlers.httpResponse(error)
        ),
        unknown: this.resolveErrorHandler(handleUnknownErrors, () =>
          this.defaultHandlers.unknown()
        ),
      },
    };
  }

  /**
   * Handle an incoming request by matching it to a registered route.
   *
   * This is the main entry point called by the server. It:
   * 1. Matches the request path + method to a registered route
   * 2. Injects extracted path params into the request
   * 3. Validates the request (if enabled)
   * 4. Calls the handler
   * 5. Returns the response
   *
   * @param request - The incoming IHttpRequest
   * @returns The IHttpResponse, or undefined if no route matched
   */
  public async handle(request: IHttpRequest): Promise<IHttpResponse | undefined> {
    const match = this.matchRoute(request.method, request.path);
    if (!match) {
      return undefined;
    }

    // Inject extracted path params into the request
    const enrichedRequest: IHttpRequest = {
      ...request,
      param: Object.keys(match.params).length > 0 ? match.params : undefined,
    };

    return this.executeHandler(enrichedRequest, match.route);
  }

  /**
   * Register a route. Called by generated subclasses in setupRoutes().
   */
  protected addRoute(
    method: HttpMethod,
    path: string,
    validator: IRequestValidator,
    handler: RequestHandler<IHttpRequest, IHttpResponse>
  ): void {
    this.routes.push({
      method,
      pattern: this.parsePattern(path),
      validator,
      handler,
    });
  }

  /**
   * Execute the handler for a matched route with validation and error handling.
   */
  private async executeHandler(
    request: IHttpRequest,
    route: Route
  ): Promise<IHttpResponse> {
    try {
      const validatedRequest = this.config.validateRequests
        ? route.validator.validate(request)
        : request;

      return await route.handler(validatedRequest);
    } catch (error) {
      return this.handleError(error, request);
    }
  }

  /**
   * Handle errors in priority order: validation → HTTP response → unknown.
   */
  private async handleError(
    error: unknown,
    request: IHttpRequest
  ): Promise<IHttpResponse> {
    if (
      error instanceof RequestValidationError &&
      this.config.errorHandlers.validation
    ) {
      try {
        return await this.config.errorHandlers.validation(error, request);
      } catch {
        // Fall through to next handler
      }
    }

    if (
      error instanceof HttpResponse &&
      this.config.errorHandlers.httpResponse
    ) {
      try {
        return await this.config.errorHandlers.httpResponse(error, request);
      } catch {
        // Fall through to next handler
      }
    }

    if (this.config.errorHandlers.unknown) {
      try {
        return await this.config.errorHandlers.unknown(error, request);
      } catch {
        // Fall through
      }
    }

    // Nothing handled it — re-throw
    throw error;
  }

  /**
   * Match a request method + path against registered routes.
   */
  private matchRoute(
    method: HttpMethod,
    path: string
  ): RouteMatch | undefined {
    const normalizedPath = this.normalizePath(path);
    const incomingSegments = normalizedPath.split("/").filter(Boolean);

    for (const route of this.routes) {
      if (route.method !== method) continue;

      const params = this.matchPattern(route.pattern, incomingSegments);
      if (params !== undefined) {
        return { route, params };
      }
    }

    return undefined;
  }

  /**
   * Try to match a route pattern against incoming path segments.
   * Returns extracted params on match, undefined on no match.
   */
  private matchPattern(
    pattern: RoutePattern,
    incomingSegments: string[]
  ): Record<string, string> | undefined {
    if (pattern.segments.length !== incomingSegments.length) {
      return undefined;
    }

    const params: Record<string, string> = {};

    for (let i = 0; i < pattern.segments.length; i++) {
      const segment = pattern.segments[i]!;
      const incoming = incomingSegments[i]!;

      if (segment.type === "literal") {
        if (segment.value !== incoming) {
          return undefined;
        }
      } else {
        params[segment.name] = decodeURIComponent(incoming);
      }
    }

    return params;
  }

  /**
   * Parse a route pattern string into segments.
   * E.g., "/todos/:todoId/subtodos/:subtodoId" →
   *   [literal("todos"), param("todoId"), literal("subtodos"), param("subtodoId")]
   */
  private parsePattern(path: string): RoutePattern {
    const segments: RouteSegment[] = this.normalizePath(path)
      .split("/")
      .filter(Boolean)
      .map(segment =>
        segment.startsWith(":")
          ? { type: "param" as const, name: segment.slice(1) }
          : { type: "literal" as const, value: segment }
      );

    return { source: path, segments };
  }

  /**
   * Normalize a path: strip query string and trailing slash.
   */
  private normalizePath(path: string): string {
    const queryIndex = path.indexOf("?");
    const pathOnly = queryIndex >= 0 ? path.slice(0, queryIndex) : path;
    return pathOnly.endsWith("/") && pathOnly.length > 1
      ? pathOnly.slice(0, -1)
      : pathOnly;
  }

  private resolveErrorHandler<T extends (...args: any[]) => any>(
    option: T | boolean | undefined,
    defaultHandler: T
  ): T | undefined {
    if (option === false) return undefined;
    if (option === true || option === undefined) return defaultHandler;
    return option;
  }
}
