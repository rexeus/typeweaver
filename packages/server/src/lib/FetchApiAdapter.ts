/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type {
  HttpMethod,
  IHttpBody,
  IHttpHeader,
  IHttpQuery,
  IHttpRequest,
  IHttpResponse,
} from "@rexeus/typeweaver-core";
import {
  BodyParseError,
  PayloadTooLargeError,
  ResponseSerializationError,
} from "./Errors";

export type FetchApiAdapterOptions = {
  readonly maxBodySize?: number;
};

/**
 * Converts between Fetch API `Request`/`Response` and typeweaver's
 * `IHttpRequest`/`IHttpResponse` at the server boundary.
 *
 * This is the **only** place where framework-specific types exist.
 * Everything inside the middleware pipeline and handlers works
 * exclusively with typeweaver's native types.
 *
 * Works with all runtimes that support the Fetch API:
 * Bun, Deno, Node.js (>=18), Cloudflare Workers.
 */
export class FetchApiAdapter {
  private static readonly DEFAULT_MAX_BODY_SIZE = 1_048_576; // 1 MB

  private readonly maxBodySize: number;

  public constructor(options?: FetchApiAdapterOptions) {
    this.maxBodySize =
      options?.maxBodySize ?? FetchApiAdapter.DEFAULT_MAX_BODY_SIZE;
  }

  /**
   * Converts a Fetch API Request to an IHttpRequest.
   *
   * Accepts an optional pre-parsed URL to avoid redundant parsing.
   *
   * @param request - The Fetch API Request object
   * @param url - Optional pre-parsed URL object to avoid double parsing
   * @returns Promise resolving to an IHttpRequest
   * @throws BodyParseError when the request body is malformed
   */
  public async toRequest(request: Request, url?: URL): Promise<IHttpRequest> {
    const parsedUrl = url ?? new URL(request.url);

    return {
      method: request.method.toUpperCase() as HttpMethod,
      path: parsedUrl.pathname,
      header: FetchApiAdapter.extractHeaders(request.headers),
      query: FetchApiAdapter.extractQueryParams(parsedUrl),
      body: await this.parseRequestBody(request),
    };
  }

  /**
   * Converts an IHttpResponse to a Fetch API Response.
   *
   * @param response - The IHttpResponse to convert
   * @returns A Fetch API Response object
   */
  public toResponse(response: IHttpResponse): Response {
    const { statusCode, body, header } = response;

    return new Response(FetchApiAdapter.serializeResponseBody(body), {
      status: statusCode,
      headers: FetchApiAdapter.buildResponseHeaders(header, body),
    });
  }

  private static extractMediaType(contentType: string | null): string | null {
    if (!contentType) return null;
    return contentType.split(";")[0]!.trim().toLowerCase();
  }

  private static isJsonContentType(contentType: string | null): boolean {
    const mediaType = FetchApiAdapter.extractMediaType(contentType);
    if (!mediaType) return false;
    return mediaType === "application/json" || mediaType.endsWith("+json");
  }

  private static isTextContentType(contentType: string | null): boolean {
    const mediaType = FetchApiAdapter.extractMediaType(contentType);
    if (!mediaType) return false;
    return mediaType.startsWith("text/");
  }

  private static isFormUrlencodedContentType(
    contentType: string | null
  ): boolean {
    return (
      FetchApiAdapter.extractMediaType(contentType) ===
      "application/x-www-form-urlencoded"
    );
  }

  private static isMultipartFormDataContentType(
    contentType: string | null
  ): boolean {
    return (
      FetchApiAdapter.extractMediaType(contentType) === "multipart/form-data"
    );
  }

  private static extractHeaders(headers: Headers): IHttpHeader {
    const result: Record<string, string | string[]> = Object.create(null);
    headers.forEach((value, key) => {
      FetchApiAdapter.addMultiValue(result, key, value);
    });
    return Object.keys(result).length > 0 ? result : undefined;
  }

  private static extractQueryParams(url: URL): IHttpQuery {
    const result: Record<string, string | string[]> = Object.create(null);
    url.searchParams.forEach((value, key) => {
      FetchApiAdapter.addMultiValue(result, key, value);
    });
    return Object.keys(result).length > 0 ? result : undefined;
  }

  private async parseRequestBody(request: Request): Promise<IHttpBody> {
    if (!request.body) return undefined;

    const checkedRequest = await this.enforceBodySizeLimit(request);
    const contentType = checkedRequest.headers.get("content-type");

    if (FetchApiAdapter.isJsonContentType(contentType)) {
      return FetchApiAdapter.parseJsonBody(checkedRequest);
    }
    if (FetchApiAdapter.isTextContentType(contentType)) {
      return FetchApiAdapter.parseTextBody(checkedRequest);
    }
    if (FetchApiAdapter.isFormUrlencodedContentType(contentType)) {
      return FetchApiAdapter.parseFormUrlencodedBody(checkedRequest);
    }
    if (FetchApiAdapter.isMultipartFormDataContentType(contentType)) {
      return FetchApiAdapter.parseMultipartBody(checkedRequest);
    }
    return FetchApiAdapter.parseRawBody(checkedRequest);
  }

  private static async parseJsonBody(request: Request): Promise<IHttpBody> {
    try {
      const text = await request.text();
      return JSON.parse(text, (key, value) => {
        if (key === "__proto__") return undefined;
        return value;
      });
    } catch (error) {
      throw new BodyParseError("Invalid JSON in request body", {
        cause: error,
      });
    }
  }

  private static async parseTextBody(request: Request): Promise<IHttpBody> {
    try {
      return await request.text();
    } catch (error) {
      throw new BodyParseError("Failed to read text request body", {
        cause: error,
      });
    }
  }

  private static async parseFormUrlencodedBody(
    request: Request
  ): Promise<IHttpBody> {
    let text: string;
    try {
      text = await request.text();
    } catch (error) {
      throw new BodyParseError("Failed to read form-urlencoded request body", {
        cause: error,
      });
    }

    const result: Record<string, string | string[]> = Object.create(null);
    new URLSearchParams(text).forEach((value, key) => {
      FetchApiAdapter.addMultiValue(result, key, value);
    });
    return result;
  }

  private static async parseMultipartBody(
    request: Request
  ): Promise<IHttpBody> {
    let formData: FormData;
    try {
      formData = await request.formData();
    } catch (error) {
      throw new BodyParseError("Invalid multipart/form-data in request body", {
        cause: error,
      });
    }

    const result: Record<string, string | File | (string | File)[]> =
      Object.create(null);
    formData.forEach((value, key) => {
      const existing = result[key];
      if (existing === undefined) {
        result[key] = value;
      } else if (Array.isArray(existing)) {
        existing.push(value);
      } else {
        result[key] = [existing, value];
      }
    });
    return result;
  }

  private static async parseRawBody(request: Request): Promise<IHttpBody> {
    try {
      const text = await request.text();
      return text || undefined;
    } catch (error) {
      throw new BodyParseError("Failed to read request body", {
        cause: error,
      });
    }
  }

  private async enforceBodySizeLimit(request: Request): Promise<Request> {
    const contentLengthHeader = request.headers.get("content-length");
    if (contentLengthHeader === null) {
      return this.readBodyWithLimit(request);
    }

    const contentLength = Number(contentLengthHeader);
    if (!Number.isFinite(contentLength) || contentLength < 0) {
      return this.readBodyWithLimit(request);
    }

    if (contentLength > this.maxBodySize) {
      throw new PayloadTooLargeError(contentLength, this.maxBodySize);
    }

    return request;
  }

  private async readBodyWithLimit(request: Request): Promise<Request> {
    if (!request.body) return request;

    const reader = request.body.getReader();
    const chunks: Uint8Array[] = [];
    let totalBytes = 0;

    try {
      for (;;) {
        const { done, value } = await reader.read();
        if (done) break;

        totalBytes += value.byteLength;
        if (totalBytes > this.maxBodySize) {
          await reader.cancel();
          throw new PayloadTooLargeError(totalBytes, this.maxBodySize);
        }
        chunks.push(value);
      }
    } finally {
      reader.releaseLock();
    }

    return new Request(request.url, {
      method: request.method,
      headers: request.headers,
      body: FetchApiAdapter.concatChunks(chunks, totalBytes),
    });
  }

  private static concatChunks(
    chunks: Uint8Array[],
    totalBytes: number
  ): Uint8Array {
    const buffer = new Uint8Array(totalBytes);
    let offset = 0;
    for (const chunk of chunks) {
      buffer.set(chunk, offset);
      offset += chunk.byteLength;
    }
    return buffer;
  }

  private static serializeResponseBody(
    body: any
  ): string | ArrayBuffer | Blob | null {
    if (body === undefined || body === null) return null;
    if (typeof body === "string") return body;
    if (body instanceof Blob || body instanceof ArrayBuffer) return body;

    try {
      return JSON.stringify(body);
    } catch (error) {
      throw new ResponseSerializationError(
        "Failed to serialize response body to JSON",
        { cause: error }
      );
    }
  }

  private static buildResponseHeaders(
    header?: IHttpHeader,
    body?: any
  ): Headers {
    const headers = new Headers();

    if (header) {
      for (const [key, value] of Object.entries(header)) {
        if (value === undefined) continue;
        if (Array.isArray(value)) {
          for (const v of value) headers.append(key, v);
        } else {
          headers.set(key, String(value));
        }
      }
    }

    if (!headers.has("content-type") && FetchApiAdapter.isJsonBody(body)) {
      headers.set("content-type", "application/json");
    }

    return headers;
  }

  private static isJsonBody(body: any): boolean {
    return (
      body !== undefined &&
      body !== null &&
      typeof body !== "string" &&
      !(body instanceof Blob) &&
      !(body instanceof ArrayBuffer)
    );
  }

  private static addMultiValue(
    record: Record<string, string | string[]>,
    key: string,
    value: string
  ): void {
    const existing = record[key];
    if (existing === undefined) {
      record[key] = value;
    } else if (Array.isArray(existing)) {
      existing.push(value);
    } else {
      record[key] = [existing, value];
    }
  }
}
