/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type {
  HttpMethod,
  IHttpBody,
  IHttpHeader,
  IHttpQuery,
  IHttpRequest,
  IHttpResponse,
} from "@rexeus/typeweaver-core";

/**
 * Error thrown when the request body cannot be parsed.
 * Caught by TypeweaverApp to return a 400 Bad Request response.
 */
export class BodyParseError extends Error {
  public override readonly name = "BodyParseError";
}

export class PayloadTooLargeError extends Error {
  public override readonly name = "PayloadTooLargeError";
  public constructor(
    public readonly contentLength: number,
    public readonly maxBodySize: number
  ) {
    super(
      `Request body too large: ${contentLength} bytes exceeds limit of ${maxBodySize} bytes`
    );
  }
}

export type FetchApiAdapterOptions = {
  readonly maxBodySize?: number;
};

/**
 * Converts between Fetch API `Request`/`Response` and typeweaver's
 * `IHttpRequest`/`IHttpResponse` at the server boundary.
 *
 * This is the **only** place where framework-specific types exist.
 * Everything inside the middleware pipeline and handlers works
 * exclusively with typeweaver's native types.
 *
 * Works with all runtimes that support the Fetch API:
 * Bun, Deno, Node.js (>=18), Cloudflare Workers.
 */
export class FetchApiAdapter {
  private readonly maxBodySize: number | undefined;

  public constructor(options?: FetchApiAdapterOptions) {
    this.maxBodySize = options?.maxBodySize;
  }

  /**
   * Converts a Fetch API Request to an IHttpRequest.
   *
   * Accepts an optional pre-parsed URL to avoid redundant parsing.
   *
   * @param request - The Fetch API Request object
   * @param url - Optional pre-parsed URL object to avoid double parsing
   * @returns Promise resolving to an IHttpRequest
   * @throws BodyParseError when the request body is malformed
   */
  public async toRequest(request: Request, url?: URL): Promise<IHttpRequest> {
    const parsedUrl = url ?? new URL(request.url);

    return {
      method: request.method.toUpperCase() as HttpMethod,
      path: parsedUrl.pathname,
      header: this.extractHeaders(request.headers),
      query: this.extractQueryParams(parsedUrl),
      body: await this.parseRequestBody(request),
    };
  }

  /**
   * Converts an IHttpResponse to a Fetch API Response.
   *
   * @param response - The IHttpResponse to convert
   * @returns A Fetch API Response object
   */
  public toResponse(response: IHttpResponse): Response {
    const { statusCode, body, header } = response;

    return new Response(this.buildResponseBody(body), {
      status: statusCode,
      headers: this.buildResponseHeaders(header, body),
    });
  }

  private addMultiValue(
    record: Record<string, string | string[]>,
    key: string,
    value: string
  ): void {
    const existing = record[key];
    if (existing) {
      if (Array.isArray(existing)) {
        existing.push(value);
      } else {
        record[key] = [existing, value];
      }
    } else {
      record[key] = value;
    }
  }

  private extractHeaders(headers: Headers): IHttpHeader {
    const result: Record<string, string | string[]> = Object.create(null);
    headers.forEach((value, key) => {
      if (!value) return;
      this.addMultiValue(result, key, value);
    });
    return Object.keys(result).length > 0 ? result : undefined;
  }

  private extractQueryParams(url: URL): IHttpQuery {
    const result: Record<string, string | string[]> = Object.create(null);
    url.searchParams.forEach((value, key) => {
      this.addMultiValue(result, key, value);
    });
    return Object.keys(result).length > 0 ? result : undefined;
  }

  private async parseRequestBody(request: Request): Promise<IHttpBody> {
    if (!request.body) return undefined;

    if (this.maxBodySize !== undefined) {
      const contentLength = Number(request.headers.get("content-length"));
      if (Number.isFinite(contentLength) && contentLength > this.maxBodySize) {
        throw new PayloadTooLargeError(contentLength, this.maxBodySize);
      }
    }

    const contentType = request.headers.get("content-type");

    if (
      contentType?.includes("application/json") ||
      contentType?.includes("+json")
    ) {
      try {
        return await request.json();
      } catch (error) {
        throw new BodyParseError("Invalid JSON in request body", {
          cause: error,
        });
      }
    }

    if (contentType?.includes("text/")) {
      return await request.text();
    }

    if (contentType?.includes("application/x-www-form-urlencoded")) {
      const text = await request.text();
      const formData = new URLSearchParams(text);
      const formObject: Record<string, string | string[]> = Object.create(null);
      formData.forEach((value, key) => {
        this.addMultiValue(formObject, key, value);
      });
      return formObject;
    }

    if (contentType?.includes("multipart/form-data")) {
      try {
        const formData = await request.formData();
        const formObject: Record<string, string | File | (string | File)[]> =
          Object.create(null);
        formData.forEach((value, key) => {
          const existing = formObject[key];
          if (existing) {
            if (Array.isArray(existing)) {
              existing.push(value);
            } else {
              formObject[key] = [existing, value];
            }
          } else {
            formObject[key] = value;
          }
        });
        return formObject;
      } catch (error) {
        throw new BodyParseError(
          "Invalid multipart/form-data in request body",
          { cause: error }
        );
      }
    }

    try {
      const rawBody = await request.text();
      return rawBody || undefined;
    } catch (error) {
      throw new BodyParseError("Failed to read request body", { cause: error });
    }
  }

  private buildResponseBody(body: any): string | ArrayBuffer | Blob | null {
    if (body === undefined || body === null) return null;

    if (
      typeof body === "string" ||
      body instanceof Blob ||
      body instanceof ArrayBuffer
    ) {
      return body;
    }

    return JSON.stringify(body);
  }

  private buildResponseHeaders(header?: IHttpHeader, body?: any): Headers {
    const headers = new Headers();

    if (header) {
      Object.entries(header).forEach(([key, value]) => {
        if (value !== undefined) {
          if (Array.isArray(value)) {
            value.forEach(v => headers.append(key, v));
          } else {
            headers.set(key, String(value));
          }
        }
      });
    }

    // Set Content-Type if not already set and body is an object (JSON)
    if (
      !headers.has("content-type") &&
      body !== undefined &&
      body !== null &&
      typeof body !== "string" &&
      !(body instanceof Blob) &&
      !(body instanceof ArrayBuffer)
    ) {
      headers.set("content-type", "application/json");
    }

    return headers;
  }
}
