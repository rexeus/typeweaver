/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

/* eslint-disable @typescript-eslint/no-empty-object-type */

import type { IHttpResponse } from "@rexeus/typeweaver-core";
import type { Middleware } from "./Middleware";
import type { ServerContext } from "./ServerContext";
import type { TypeweaverApp } from "./TypeweaverApp";

/**
 * A middleware descriptor carrying compile-time metadata about what state
 * it provides to downstream consumers and what state it requires from
 * upstream middleware.
 *
 * Created via {@link defineMiddleware}. The `_brand` property exists purely
 * at the type level for TypeScript's inference — its runtime value is an empty object.
 *
 * @template TProvides - State keys this middleware adds to the context
 * @template TRequires - State keys this middleware expects to already exist
 */
export type TypedMiddleware<
  TProvides extends Record<string, unknown> = {},
  TRequires extends Record<string, unknown> = {},
> = {
  readonly handler: Middleware;
  readonly _brand: {
    readonly provides: TProvides;
    readonly requires: TRequires;
  };
};

/**
 * Compile-time error type produced when a typed middleware's requirements
 * are not satisfied by the current accumulated app state.
 *
 * When intersected with `TypedMiddleware`, produces an uninhabitable type —
 * no value can satisfy both, causing a clear compiler error at the call site.
 *
 * The error type's properties (`required`, `available`, `missing`) appear
 * in the compiler diagnostic, helping developers identify what's wrong.
 */
export type StateRequirementError<
  TRequired extends Record<string, unknown>,
  TAvailable extends Record<string, unknown>,
> = {
  readonly __error: "STATE_REQUIREMENT_NOT_MET";
  readonly required: TRequired;
  readonly available: TAvailable;
  readonly missing: Exclude<keyof TRequired, keyof TAvailable>;
};

/**
 * The type of the `next` function inside a typed middleware handler.
 *
 * When `TProvides` has keys, `next` requires the state object as its argument,
 * enforcing at compile time that middleware provides the state it declares.
 *
 * When `TProvides` is empty (`{}`), `next` takes no arguments — the middleware
 * is pass-through and doesn't need to provide any state.
 *
 * @template TProvides - The state keys this middleware declares it provides
 */
export type NextFn<TProvides extends Record<string, unknown>> =
  [keyof TProvides] extends [never]
    ? () => Promise<IHttpResponse>
    : (state: TProvides) => Promise<IHttpResponse>;

/**
 * Creates a typed middleware descriptor.
 *
 * The handler receives a `ServerContext` parameterized with the required
 * upstream state, and a `next` function that enforces providing the declared
 * state. When the middleware declares `TProvides`, the state must be passed
 * to `next()` — the pipeline merges it into `ctx.state` before continuing.
 *
 * @template TProvides - State keys this middleware adds
 * @template TRequires - State keys this middleware expects (defaults to none)
 *
 * @example
 * ```typescript
 * // Middleware that provides state — MUST pass it to next()
 * const auth = defineMiddleware<{ userId: string }>(async (ctx, next) => {
 *   return next({ userId: parseToken(ctx.request.header?.["authorization"]) });
 * });
 *
 * // Middleware with requirements — reads upstream state, provides new state
 * const permissions = defineMiddleware<{ permissions: string[] }, { userId: string }>(
 *   async (ctx, next) => {
 *     const userId = ctx.state.get("userId"); // string (no undefined!)
 *     return next({ permissions: await loadPermissions(userId) });
 *   }
 * );
 *
 * // Pass-through middleware — next() takes no args
 * const logger = defineMiddleware(async (ctx, next) => {
 *   console.log(ctx.request.path);
 *   return next();
 * });
 * ```
 */
export function defineMiddleware<
  TProvides extends Record<string, unknown> = {},
  TRequires extends Record<string, unknown> = {},
>(
  handler: (
    ctx: ServerContext<TRequires>,
    next: NextFn<TProvides>
  ) => Promise<IHttpResponse>
): TypedMiddleware<TProvides, TRequires> {
  return {
    handler: handler as Middleware,
    _brand: {} as TypedMiddleware<TProvides, TRequires>["_brand"],
  };
}

/**
 * Extracts the accumulated state type from a `TypeweaverApp` instance.
 *
 * Use this to derive the state type for handler implementations
 * without declaring it separately.
 *
 * @example
 * ```typescript
 * const app = new TypeweaverApp()
 *   .use(authMiddleware)
 *   .use(permissionsMiddleware);
 *
 * type AppState = InferState<typeof app>;
 * // { userId: string } & { permissions: string[] }
 *
 * const handlers: TodoApiHandler<AppState> = { ... };
 * ```
 */
export type InferState<T> = T extends TypeweaverApp<infer S> ? S : never;
