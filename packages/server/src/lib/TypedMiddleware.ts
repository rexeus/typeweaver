/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

/* eslint-disable @typescript-eslint/no-empty-object-type */

import type { IHttpResponse } from "@rexeus/typeweaver-core";
import type { Middleware } from "./Middleware";
import type { ServerContext } from "./ServerContext";
import type { TypeweaverApp } from "./TypeweaverApp";

/**
 * A middleware descriptor carrying compile-time metadata about what state
 * it provides to downstream consumers and what state it requires from
 * upstream middleware.
 *
 * Created via {@link defineMiddleware}. The `_brand` property exists purely
 * at the type level for TypeScript's inference — its runtime value is an empty object.
 *
 * @template TProvides - State keys this middleware adds to the context
 * @template TRequires - State keys this middleware expects to already exist
 */
export type TypedMiddleware<
  TProvides extends Record<string, unknown> = {},
  TRequires extends Record<string, unknown> = {},
> = {
  readonly handler: Middleware;
  readonly _brand: {
    readonly provides: TProvides;
    readonly requires: TRequires;
  };
};

/**
 * Compile-time error type produced when a typed middleware's requirements
 * are not satisfied by the current accumulated app state.
 *
 * When intersected with `TypedMiddleware`, produces an uninhabitable type —
 * no value can satisfy both, causing a clear compiler error at the call site.
 *
 * The error type's properties (`required`, `available`, `missing`) appear
 * in the compiler diagnostic, helping developers identify what's wrong.
 */
export type StateRequirementError<
  TRequired extends Record<string, unknown>,
  TAvailable extends Record<string, unknown>,
> = {
  readonly __error: "STATE_REQUIREMENT_NOT_MET";
  readonly required: TRequired;
  readonly available: TAvailable;
  readonly missing: Exclude<keyof TRequired, keyof TAvailable>;
};

/**
 * Creates a typed middleware descriptor.
 *
 * The handler receives a `ServerContext` parameterized with both the
 * required and provided state, allowing it to read required state and
 * write provided state with full type safety.
 *
 * @template TProvides - State keys this middleware adds
 * @template TRequires - State keys this middleware expects (defaults to none)
 *
 * @example
 * ```typescript
 * // Simple middleware — no requirements
 * const auth = defineMiddleware<{ userId: string }>(async (ctx, next) => {
 *   ctx.state.set("userId", parseToken(ctx.request.header?.["authorization"]));
 *   return next();
 * });
 *
 * // Middleware with requirements
 * const permissions = defineMiddleware<{ permissions: string[] }, { userId: string }>(
 *   async (ctx, next) => {
 *     const userId = ctx.state.get("userId");
 *     ctx.state.set("permissions", await loadPermissions(userId!));
 *     return next();
 *   }
 * );
 * ```
 */
export function defineMiddleware<
  TProvides extends Record<string, unknown> = {},
  TRequires extends Record<string, unknown> = {},
>(
  handler: (
    ctx: ServerContext<TRequires & TProvides>,
    next: () => Promise<IHttpResponse>
  ) => Promise<IHttpResponse>
): TypedMiddleware<TProvides, TRequires> {
  return {
    handler: handler as Middleware,
    _brand: {} as TypedMiddleware<TProvides, TRequires>["_brand"],
  };
}

/**
 * Extracts the accumulated state type from a `TypeweaverApp` instance.
 *
 * Use this to derive the state type for handler implementations
 * without declaring it separately.
 *
 * @example
 * ```typescript
 * const app = new TypeweaverApp()
 *   .use(authMiddleware)
 *   .use(permissionsMiddleware);
 *
 * type AppState = InferState<typeof app>;
 * // { userId: string } & { permissions: string[] }
 *
 * const handlers: TodoApiHandler<AppState> = { ... };
 * ```
 */
export type InferState<T> = T extends TypeweaverApp<infer S> ? S : never;
