/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

/**
 * A type-safe wrapper around `Map<string, unknown>` for middleware state.
 *
 * When parameterized with a specific state shape, provides compile-time
 * type safety for `get`/`set`/`has` operations. When using the default
 * `Record<string, unknown>`, behaves identically to `Map<string, unknown>`.
 *
 * The API surface is intentionally narrow (`get`, `set`, `has` only).
 * Generic `Map` methods like `forEach`, `entries`, or `delete` are excluded
 * to prevent bypassing type safety.
 *
 * @template TState - The shape of state this map carries
 *
 * @example
 * ```typescript
 * // Untyped (default) — accepts any key/value
 * const state = new StateMap();
 * state.set("anything", 42);
 * state.get("anything"); // unknown | undefined
 *
 * // Typed — constrains keys and values
 * type MyState = { userId: string; role: "admin" | "user" };
 * const typed = new StateMap<MyState>();
 * typed.set("userId", "u_123");     // ✓
 * typed.set("userId", 123);         // ✗ compile error
 * typed.get("userId");              // string | undefined
 * typed.get("nonexistent");         // ✗ compile error
 * ```
 */
export class StateMap<TState extends Record<string, unknown> = Record<string, unknown>> {
  private readonly map = new Map<string, unknown>();

  public set<K extends string & keyof TState>(key: K, value: TState[K]): void {
    this.map.set(key, value);
  }

  public get<K extends string & keyof TState>(key: K): TState[K] | undefined {
    return this.map.get(key) as TState[K] | undefined;
  }

  public has<K extends string & keyof TState>(key: K): boolean {
    return this.map.has(key);
  }
}
