/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type {
  HttpMethod,
  IHttpResponse,
  IRequestValidator,
  RequestValidationError,
} from "@rexeus/typeweaver-core";
import type { RequestHandler } from "./RequestHandler";
import type { ServerContext } from "./ServerContext";

/**
 * A registered route with its method, path pattern, validator, and handler.
 */
export type RouteDefinition = {
  readonly method: HttpMethod;
  readonly path: string;
  readonly validator: IRequestValidator;
  readonly handler: RequestHandler;
  /** Reference to the router config for error handling. */
  readonly routerConfig: RouterErrorConfig;
};

/**
 * Error handling configuration associated with a router.
 */
export type RouterErrorConfig = {
  readonly validateRequests: boolean;
  readonly handleHttpResponseErrors: HttpResponseErrorHandler | boolean;
  readonly handleValidationErrors: ValidationErrorHandler | boolean;
  readonly handleUnknownErrors: UnknownErrorHandler | boolean;
};

/**
 * Handles HTTP response errors thrown by request handlers.
 * The error parameter is an `HttpResponse` instance (thrown via `throw new HttpResponse(...)`).
 */
export type HttpResponseErrorHandler = (
  error: IHttpResponse,
  ctx: ServerContext
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Handles request validation errors.
 */
export type ValidationErrorHandler = (
  error: RequestValidationError,
  ctx: ServerContext
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Handles any unknown errors not caught by other handlers.
 */
export type UnknownErrorHandler = (
  error: unknown,
  ctx: ServerContext
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Result of a successful route match.
 */
export type RouteMatch = {
  readonly route: RouteDefinition;
  readonly params: Record<string, string>;
};

/**
 * A node in the radix tree.
 *
 * Each node represents a single path segment.
 * Static children are stored in a `Map` keyed by segment string.
 * A single `paramChild` holds the branch for `:param` segments.
 * Leaf nodes store a `Map` of HTTP method → route definition.
 */
type RadixNode = {
  readonly staticChildren: Map<string, RadixNode>;
  paramChild: { readonly name: string; readonly node: RadixNode } | undefined;
  readonly methods: Map<string, RouteDefinition>;
};

/**
 * High-performance radix tree router with path parameter support.
 *
 * Routes are stored in a tree structure where each level corresponds
 * to a path segment. This gives O(d) lookup time where d is the depth
 * (number of segments) of the URL — independent of the total number
 * of registered routes.
 *
 * Supports:
 * - Static paths: `/accounts`
 * - Named parameters: `/todos/:todoId`
 * - Multiple parameters: `/todos/:todoId/subtodos/:subtodoId`
 * - Automatic HEAD → GET fallback (per HTTP spec)
 * - 405 Method Not Allowed detection with `Allow` header
 *
 * Path matching for middleware uses wildcard support:
 * - `/todos/*` matches `/todos/123`, `/todos/123/subtodos`, etc.
 */
export class Router {
  private readonly root: RadixNode = Router.createNode();

  /**
   * Register a route in the radix tree.
   */
  public add(definition: RouteDefinition): void {
    const segments = Router.toSegments(definition.path);

    let current = this.root;

    for (const segment of segments) {
      if (segment.startsWith(":")) {
        const paramName = segment.slice(1);
        if (!current.paramChild) {
          current.paramChild = { name: paramName, node: Router.createNode() };
        }
        current = current.paramChild.node;
      } else {
        let child = current.staticChildren.get(segment);
        if (!child) {
          child = Router.createNode();
          current.staticChildren.set(segment, child);
        }
        current = child;
      }
    }

    current.methods.set(definition.method, definition);
  }

  /**
   * Find a matching route for the given method and path.
   *
   * Traverses the radix tree in O(d) time where d is the number
   * of path segments. Static segments are matched first (exact match),
   * then parameterized segments are tried as fallback.
   *
   * For HEAD requests, automatically falls back to the GET handler
   * if no explicit HEAD handler is registered (per HTTP spec).
   *
   * @returns The matched route with extracted path parameters, or `undefined` if no match.
   */
  public match(method: string, path: string): RouteMatch | undefined {
    const upperMethod = method.toUpperCase();
    const segments = Router.toSegments(path);
    const params: Record<string, string> = {};

    const node = this.traverse(this.root, segments, 0, params);
    if (!node) return undefined;

    const definition =
      node.methods.get(upperMethod) ??
      (upperMethod === "HEAD" ? node.methods.get("GET") : undefined);

    if (!definition) return undefined;

    return { route: definition, params };
  }

  /**
   * Find a matching node for the given path, regardless of HTTP method.
   *
   * Used to distinguish "path not found" (404) from "method not allowed" (405).
   *
   * @returns The allowed methods for this path, or `undefined` if the path doesn't exist.
   */
  public matchPath(path: string): { allowedMethods: string[] } | undefined {
    const segments = Router.toSegments(path);
    const params: Record<string, string> = {};

    const node = this.traverse(this.root, segments, 0, params);
    if (!node || node.methods.size === 0) return undefined;

    const methods = Array.from(node.methods.keys());
    if (methods.includes("GET") && !methods.includes("HEAD")) {
      methods.push("HEAD");
    }

    return { allowedMethods: methods.sort() };
  }

  /**
   * Check if a request path matches a middleware path pattern.
   *
   * Supports wildcard (`*`) at the end: `/todos/*` matches `/todos/123/subtodos`.
   * An `undefined` pattern matches everything.
   */
  public static matchesMiddlewarePath(
    pattern: string | undefined,
    requestPath: string
  ): boolean {
    if (pattern === undefined) return true;

    // Exact match
    if (pattern === requestPath) return true;

    // Wildcard: /foo/* matches /foo/anything
    if (pattern.endsWith("/*")) {
      const prefix = pattern.slice(0, -1); // "/foo/"
      return (
        requestPath.startsWith(prefix) || requestPath === pattern.slice(0, -2)
      );
    }

    return false;
  }

  /**
   * Recursively traverse the radix tree to find a matching node.
   *
   * Prioritises static children over param children for correct
   * and predictable matching behaviour.
   *
   * Path parameters are URL-decoded during extraction.
   */
  private traverse(
    node: RadixNode,
    segments: string[],
    index: number,
    params: Record<string, string>
  ): RadixNode | undefined {
    // All segments consumed — this node is the match candidate
    if (index === segments.length) {
      return node;
    }

    const segment = segments[index]!;

    // 1. Try static child first (higher priority)
    const staticChild = node.staticChildren.get(segment);
    if (staticChild) {
      const result = this.traverse(staticChild, segments, index + 1, params);
      if (result && result.methods.size > 0) return result;
    }

    // 2. Try param child as fallback
    if (node.paramChild) {
      const { name, node: paramNode } = node.paramChild;
      params[name] = Router.decodePathSegment(segment);
      const result = this.traverse(paramNode, segments, index + 1, params);
      if (result && result.methods.size > 0) return result;
      // Backtrack: remove param if this branch didn't match
      delete params[name];
    }

    return undefined;
  }

  private static createNode(): RadixNode {
    return {
      staticChildren: new Map(),
      paramChild: undefined,
      methods: new Map(),
    };
  }

  private static decodePathSegment(segment: string): string {
    try {
      return decodeURIComponent(segment);
    } catch {
      return segment;
    }
  }

  private static toSegments(path: string): string[] {
    return path.split("/").filter(s => s.length > 0);
  }
}
