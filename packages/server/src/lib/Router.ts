/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type { IHttpRequest, IHttpResponse, IRequestValidator } from "@rexeus/typeweaver-core";
import type { RequestHandler } from "./RequestHandler";

/**
 * A registered route with its method, path pattern, validator, and handler.
 */
export type RouteDefinition = {
  method: string;
  path: string;
  validator: IRequestValidator;
  handler: RequestHandler<any, any>;
  /** Reference to the server config for error handling. */
  serverConfig: ServerErrorConfig;
};

/**
 * Error handling configuration associated with a server.
 */
export type ServerErrorConfig = {
  validateRequests: boolean;
  handleHttpResponseErrors: HttpResponseErrorHandler | boolean;
  handleValidationErrors: ValidationErrorHandler | boolean;
  handleUnknownErrors: UnknownErrorHandler | boolean;
};

import type { ServerContext } from "./ServerContext";

/**
 * Handles HTTP response errors thrown by request handlers.
 */
export type HttpResponseErrorHandler = (
  error: IHttpResponse,
  ctx: ServerContext
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Handles request validation errors.
 */
export type ValidationErrorHandler = (
  error: import("@rexeus/typeweaver-core").RequestValidationError,
  ctx: ServerContext
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Handles any unknown errors not caught by other handlers.
 */
export type UnknownErrorHandler = (
  error: unknown,
  ctx: ServerContext
) => Promise<IHttpResponse> | IHttpResponse;

/**
 * Internal representation of a parsed route for efficient matching.
 */
type CompiledRoute = {
  definition: RouteDefinition;
  method: string;
  segments: string[];
  paramNames: string[];
};

/**
 * Result of a successful route match.
 */
export type RouteMatch = {
  route: RouteDefinition;
  params: Record<string, string>;
};

/**
 * Lightweight router with path parameter support.
 *
 * Supports:
 * - Static paths: `/accounts`
 * - Named parameters: `/todos/:todoId`
 * - Multiple parameters: `/todos/:todoId/subtodos/:subtodoId`
 *
 * Path matching for middleware uses wildcard support:
 * - `/todos/*` matches `/todos/123`, `/todos/123/subtodos`, etc.
 */
export class Router {
  private routes: CompiledRoute[] = [];

  /**
   * Register a route.
   */
  public add(definition: RouteDefinition): void {
    const segments = this.toSegments(definition.path);
    const paramNames = segments
      .filter(s => s.startsWith(":"))
      .map(s => s.slice(1));

    this.routes.push({
      definition,
      method: definition.method.toUpperCase(),
      segments,
      paramNames,
    });
  }

  /**
   * Find a matching route for the given method and path.
   *
   * @returns The matched route with extracted path parameters, or `undefined` if no match.
   */
  public match(method: string, path: string): RouteMatch | undefined {
    const upperMethod = method.toUpperCase();
    const requestSegments = this.toSegments(path);

    for (const route of this.routes) {
      if (route.method !== upperMethod) continue;
      if (route.segments.length !== requestSegments.length) continue;

      const params = this.matchSegments(route.segments, requestSegments);
      if (params !== undefined) {
        return { route: route.definition, params };
      }
    }

    return undefined;
  }

  /**
   * Check if a request path matches a middleware path pattern.
   *
   * Supports wildcard (`*`) at the end: `/todos/*` matches `/todos/123/subtodos`.
   * A `undefined` pattern matches everything.
   */
  public static matchesMiddlewarePath(
    pattern: string | undefined,
    requestPath: string
  ): boolean {
    if (pattern === undefined) return true;

    // Exact match
    if (pattern === requestPath) return true;

    // Wildcard: /foo/* matches /foo/anything
    if (pattern.endsWith("/*")) {
      const prefix = pattern.slice(0, -1); // "/foo/"
      return requestPath.startsWith(prefix) || requestPath === pattern.slice(0, -2);
    }

    return false;
  }

  private toSegments(path: string): string[] {
    return path.split("/").filter(s => s.length > 0);
  }

  private matchSegments(
    routeSegments: string[],
    requestSegments: string[]
  ): Record<string, string> | undefined {
    const params: Record<string, string> = {};

    for (let i = 0; i < routeSegments.length; i++) {
      const routeSeg = routeSegments[i]!;
      const reqSeg = requestSegments[i]!;

      if (routeSeg.startsWith(":")) {
        // Named parameter â€” capture value
        params[routeSeg.slice(1)] = reqSeg;
      } else if (routeSeg !== reqSeg) {
        // Static segment mismatch
        return undefined;
      }
    }

    return params;
  }
}
