/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import { HttpResponse, RequestValidationError } from "@rexeus/typeweaver-core";
import type { IHttpResponse } from "@rexeus/typeweaver-core";
import { BodyParseError, PayloadTooLargeError } from "./Errors";
import { FetchApiAdapter } from "./FetchApiAdapter";
import { executeMiddlewarePipeline } from "./Middleware";
import { Router } from "./Router";
import { StateMap } from "./StateMap";
import type { Middleware } from "./Middleware";
import type { RequestHandler } from "./RequestHandler";
import type {
  HttpResponseErrorHandler,
  RouteDefinition,
  UnknownErrorHandler,
  ValidationErrorHandler,
} from "./Router";
import type { ServerContext } from "./ServerContext";
import type { StateRequirementError, TypedMiddleware } from "./TypedMiddleware";
import type { TypeweaverRouter } from "./TypeweaverRouter";

/**
 * The main application class that provides routing, middleware, and
 * request handling â€” all using typeweaver's native `IHttpRequest`/`IHttpResponse` format.
 *
 * Exposes a single `fetch()` method compatible with Bun, Deno, Cloudflare Workers,
 * and adaptable to Node.js `http.createServer`.
 *
 * Internally, the entire pipeline operates on `IHttpRequest`/`IHttpResponse`.
 * Conversion from/to Fetch API `Request`/`Response` happens **only** at the boundary.
 *
 * Middleware is return-based: each middleware returns an `IHttpResponse`
 * instead of mutating shared state.
 *
 * Middleware runs for **all** requests, including 404s and 405s, so global
 * concerns like logging and CORS always execute.
 *
 * @example
 * ```typescript
 * const app = new TypeweaverApp()
 *   .use(authMiddleware)       // defineMiddleware<{ userId: string }>
 *   .use(permissionsMiddleware) // defineMiddleware<{ perms: string[] }, { userId: string }>
 *   .route(new TodoRouter({ requestHandlers: { ... } }));
 *
 * Bun.serve({ fetch: app.fetch, port: 3000 });
 * ```
 */
export type TypeweaverAppOptions = {
  readonly maxBodySize?: number;
  readonly onError?: (error: unknown) => void;
};

export class TypeweaverApp<TState extends Record<string, unknown> = {}> {
  private static readonly INTERNAL_SERVER_ERROR_BODY = {
    code: "INTERNAL_SERVER_ERROR",
    message: "An unexpected error occurred",
  } as const;

  private readonly router = new Router();
  private readonly middlewares: Middleware[] = [];
  private readonly adapter: FetchApiAdapter;
  private readonly onError: (error: unknown) => void;

  public constructor(options?: TypeweaverAppOptions) {
    this.adapter = new FetchApiAdapter({ maxBodySize: options?.maxBodySize });
    this.onError = options?.onError ?? console.error;
  }

  private safeOnError(error: unknown): void {
    try {
      this.onError(error);
    } catch (onErrorFailure) {
      console.error(
        "TypeweaverApp: onError callback threw while handling error",
        { onErrorFailure, originalError: error }
      );
    }
  }

  /**
   * Register a typed middleware that provides state to downstream handlers.
   *
   * Returns a new `TypeweaverApp` type with the accumulated state.
   * Produces a compile-time error if the middleware's requirements are not met
   * by the currently accumulated state.
   *
   * Use {@link defineMiddleware} to create typed middleware.
   */
  public use<
    TProv extends Record<string, unknown>,
    TReq extends Record<string, unknown>,
  >(
    middleware: TypedMiddleware<TProv, TReq> &
      ([TState] extends [TReq] ? unknown : StateRequirementError<TReq, TState>)
  ): TypeweaverApp<TState & TProv> {
    this.middlewares.push(middleware.handler);
    return this as unknown as TypeweaverApp<TState & TProv>;
  }

  /**
   * Mount a generated `TypeweaverRouter` instance.
   *
   * Registers all routes from the router into the app.
   * Multiple routers can be mounted on the same app.
   *
   * Optionally accepts a prefix to prepend to all routes from the router.
   *
   * @example
   * ```typescript
   * app.route(new AccountRouter({ requestHandlers: { ... } }));
   * app.route("/api/v1", new TodoRouter({ requestHandlers: { ... } }));
   * ```
   */
  public route(
    router: TypeweaverRouter<Record<string, RequestHandler<any, any, any>>>
  ): this;
  public route(
    prefix: string,
    router: TypeweaverRouter<Record<string, RequestHandler<any, any, any>>>
  ): this;
  public route(
    prefixOrRouter:
      | string
      | TypeweaverRouter<Record<string, RequestHandler<any, any, any>>>,
    router?: TypeweaverRouter<Record<string, RequestHandler<any, any, any>>>
  ): this {
    if (typeof prefixOrRouter === "string") {
      if (!router) {
        throw new Error("Router is required when mounting with a prefix");
      }
      return this.mountRouter(router, prefixOrRouter);
    }
    return this.mountRouter(prefixOrRouter);
  }

  /**
   * Universal request handler compatible with Fetch API runtimes.
   *
   * The entire pipeline works with `IHttpRequest`/`IHttpResponse`.
   * Conversion from/to Fetch API `Request`/`Response` happens only here, at the boundary.
   *
   * Middleware runs for all requests (including 404s and 405s).
   * HEAD requests automatically fall back to GET handlers with body stripped from the response.
   *
   * @example
   * ```typescript
   * // Bun
   * Bun.serve({ fetch: app.fetch, port: 3000 });
   *
   * // Deno
   * Deno.serve({ port: 3000 }, app.fetch);
   * ```
   */
  public fetch = async (request: Request): Promise<Response> => {
    try {
      const response = await this.processRequest(request);
      return this.adapter.toResponse(response);
    } catch (error) {
      if (error instanceof PayloadTooLargeError) {
        this.safeOnError(error);
        return this.adapter.toResponse({
          statusCode: 413,
          body: {
            code: "PAYLOAD_TOO_LARGE",
            message: "Request body exceeds the size limit",
          },
        });
      }
      if (error instanceof BodyParseError) {
        return this.adapter.toResponse({
          statusCode: 400,
          body: { code: "BAD_REQUEST", message: "Malformed request body" },
        });
      }
      this.safeOnError(error);
      return TypeweaverApp.createErrorResponse();
    }
  };

  private async processRequest(request: Request): Promise<IHttpResponse> {
    const url = new URL(request.url);
    const httpRequest = await this.adapter.toRequest(request, url);

    const ctx: ServerContext = {
      request: httpRequest,
      state: new StateMap(),
    };

    const response = await executeMiddlewarePipeline(
      this.middlewares,
      ctx,
      () => this.resolveAndExecute(request.method, url.pathname, ctx)
    );

    return request.method.toUpperCase() === "HEAD"
      ? { ...response, body: undefined }
      : response;
  }

  /**
   * Match the route and execute the handler.
   * Called as the final handler in the middleware pipeline.
   */
  private async resolveAndExecute(
    method: string,
    pathname: string,
    ctx: ServerContext
  ): Promise<IHttpResponse> {
    const match = this.router.match(method, pathname);

    if (match) {
      const routeCtx = this.withPathParams(ctx, match.params);
      try {
        return await this.executeHandler(routeCtx, match.route);
      } catch (error) {
        return this.handleError(error, routeCtx, match.route);
      }
    }

    const pathMatch = this.router.matchPath(pathname);
    if (pathMatch) {
      return {
        statusCode: 405,
        header: { Allow: pathMatch.allowedMethods.join(", ") },
        body: {
          code: "METHOD_NOT_ALLOWED",
          message: "Method not supported for this resource",
        },
      };
    }

    return {
      statusCode: 404,
      body: { code: "NOT_FOUND", message: "No matching resource found" },
    };
  }

  private withPathParams(
    ctx: ServerContext,
    params: Record<string, string>
  ): ServerContext {
    if (Object.keys(params).length === 0) return ctx;
    return { ...ctx, request: { ...ctx.request, param: params } };
  }

  private async executeHandler(
    ctx: ServerContext,
    route: RouteDefinition
  ): Promise<IHttpResponse> {
    const validatedRequest = route.routerConfig.validateRequests
      ? route.validator.validate(ctx.request)
      : ctx.request;

    return route.handler(validatedRequest, ctx);
  }

  /**
   * Handle errors using the route's configured error handlers.
   * Handler errors bubble up to the safety net in `fetch()`.
   */
  private handleError(
    error: unknown,
    ctx: ServerContext,
    route: RouteDefinition
  ): IHttpResponse | Promise<IHttpResponse> {
    const config = route.routerConfig;

    if (error instanceof RequestValidationError) {
      const handler = this.resolveErrorHandler<ValidationErrorHandler>(
        config.handleValidationErrors,
        TypeweaverApp.defaultValidationHandler
      );
      if (handler) return handler(error, ctx);
    }

    if (error instanceof HttpResponse) {
      const handler = this.resolveErrorHandler<HttpResponseErrorHandler>(
        config.handleHttpResponseErrors,
        TypeweaverApp.defaultHttpResponseHandler
      );
      if (handler) return handler(error, ctx);
    }

    const handler = this.resolveErrorHandler<UnknownErrorHandler>(
      config.handleUnknownErrors,
      this.defaultUnknownHandler
    );
    if (handler) return handler(error, ctx);

    throw error;
  }

  /**
   * Resolve an error handler option to a concrete handler function.
   */
  private resolveErrorHandler<T extends (...args: any[]) => any>(
    option: T | boolean | undefined,
    defaultHandler: T
  ): T | undefined {
    if (option === false) return undefined;
    if (option === true || option === undefined) return defaultHandler;
    return option;
  }

  private mountRouter(
    router: TypeweaverRouter<Record<string, RequestHandler<any, any, any>>>,
    prefix?: string
  ): this {
    const normalizedPrefix = prefix?.replace(/\/+$/, "");
    for (const route of router.getRoutes()) {
      this.router.add({
        ...route,
        path: normalizedPrefix ? normalizedPrefix + route.path : route.path,
      });
    }
    return this;
  }

  private static sanitizeIssues(
    issues: readonly {
      readonly message: string;
      readonly path: PropertyKey[];
    }[]
  ): readonly { message: string; path: PropertyKey[] }[] | undefined {
    if (issues.length === 0) return undefined;
    return issues.map(({ message, path }) => ({ message, path }));
  }

  private static defaultValidationHandler: ValidationErrorHandler = (
    err
  ): IHttpResponse => {
    const issues: Record<string, unknown> = Object.create(null);

    const header = TypeweaverApp.sanitizeIssues(err.headerIssues);
    const body = TypeweaverApp.sanitizeIssues(err.bodyIssues);
    const query = TypeweaverApp.sanitizeIssues(err.queryIssues);
    const param = TypeweaverApp.sanitizeIssues(err.pathParamIssues);

    if (header) issues.header = header;
    if (body) issues.body = body;
    if (query) issues.query = query;
    if (param) issues.param = param;

    return {
      statusCode: 400,
      body: {
        code: "VALIDATION_ERROR",
        message: err.message,
        issues,
      },
    };
  };

  private static defaultHttpResponseHandler: HttpResponseErrorHandler = (
    err
  ): IHttpResponse => err;

  private readonly defaultUnknownHandler: UnknownErrorHandler = (
    error
  ): IHttpResponse => {
    this.safeOnError(error);
    return { statusCode: 500, body: TypeweaverApp.INTERNAL_SERVER_ERROR_BODY };
  };

  private static createErrorResponse(): Response {
    return new Response(
      JSON.stringify(TypeweaverApp.INTERNAL_SERVER_ERROR_BODY),
      {
        status: 500,
        headers: { "content-type": "application/json" },
      }
    );
  }
}
