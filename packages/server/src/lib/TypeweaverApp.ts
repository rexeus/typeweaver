/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import { HttpResponse, RequestValidationError } from "@rexeus/typeweaver-core";
import type { IHttpResponse } from "@rexeus/typeweaver-core";
import {
  BodyParseError,
  FetchApiAdapter,
  PayloadTooLargeError,
} from "./FetchApiAdapter";
import { executeMiddlewarePipeline } from "./Middleware";
import { Router } from "./Router";
import type { Middleware, MiddlewareEntry } from "./Middleware";
import type { RequestHandler } from "./RequestHandler";
import type {
  HttpResponseErrorHandler,
  RouteDefinition,
  UnknownErrorHandler,
  ValidationErrorHandler,
} from "./Router";
import type { ServerContext } from "./ServerContext";
import type { TypeweaverRouter } from "./TypeweaverRouter";

/**
 * The main application class that provides routing, middleware, and
 * request handling â€” all using typeweaver's native `IHttpRequest`/`IHttpResponse` format.
 *
 * Exposes a single `fetch()` method compatible with Bun, Deno, Cloudflare Workers,
 * and adaptable to Node.js `http.createServer`.
 *
 * Internally, the entire pipeline operates on `IHttpRequest`/`IHttpResponse`.
 * Conversion from/to Fetch API `Request`/`Response` happens **only** at the boundary.
 *
 * Middleware is return-based: each middleware returns an `IHttpResponse`
 * instead of mutating shared state.
 *
 * Middleware runs for **all** requests, including 404s and 405s, so global
 * concerns like logging and CORS always execute.
 *
 * @example
 * ```typescript
 * const app = new TypeweaverApp();
 *
 * // Global middleware
 * app.use(async (ctx, next) => {
 *   console.log(`${ctx.request.method} ${ctx.request.path}`);
 *   return next();
 * });
 *
 * // Path-scoped middleware (short-circuit)
 * app.use("/todos/*", async (ctx, next) => {
 *   const token = ctx.request.header?.["authorization"];
 *   if (!token) {
 *     return { statusCode: 401, body: { message: "Unauthorized" } };
 *   }
 *   return next();
 * });
 *
 * // Mount generated routers
 * app.route(new AccountRouter({ requestHandlers: { ... } }));
 * app.route("/api/v1", new TodoRouter({ requestHandlers: { ... } }));
 *
 * // Start
 * Bun.serve({ fetch: app.fetch, port: 3000 });
 * ```
 */
export type TypeweaverAppOptions = {
  readonly maxBodySize?: number;
  readonly onError?: (error: unknown) => void;
};

export class TypeweaverApp {
  private static readonly INTERNAL_SERVER_ERROR_BODY = {
    code: "INTERNAL_SERVER_ERROR",
    message: "An unexpected error occurred.",
  } as const;

  private readonly router = new Router();
  private readonly middlewares: MiddlewareEntry[] = [];
  private readonly adapter: FetchApiAdapter;
  private readonly onError: (error: unknown) => void;

  public constructor(options?: TypeweaverAppOptions) {
    this.adapter = new FetchApiAdapter({ maxBodySize: options?.maxBodySize });
    this.onError = options?.onError ?? console.error;
  }

  /**
   * Register a global middleware that runs for all requests.
   */
  public use(middleware: Middleware): this;

  /**
   * Register a path-scoped middleware that runs only for matching paths.
   *
   * Supports wildcard patterns: `/todos/*` matches `/todos/123`, `/todos/123/subtodos`, etc.
   */
  public use(path: string, middleware: Middleware): this;

  public use(
    pathOrMiddleware: string | Middleware,
    middleware?: Middleware
  ): this {
    if (typeof pathOrMiddleware === "string") {
      if (!middleware) {
        throw new Error(
          "Middleware handler is required when registering path-scoped middleware"
        );
      }
      this.middlewares.push({
        path: pathOrMiddleware,
        handler: middleware,
      });
    } else {
      this.middlewares.push({
        path: undefined,
        handler: pathOrMiddleware,
      });
    }
    return this;
  }

  /**
   * Mount a generated `TypeweaverRouter` instance.
   *
   * Registers all routes from the router into the app.
   * Multiple routers can be mounted on the same app.
   *
   * Optionally accepts a prefix to prepend to all routes from the router.
   *
   * @example
   * ```typescript
   * app.route(new AccountRouter({ requestHandlers: { ... } }));
   * app.route("/api/v1", new TodoRouter({ requestHandlers: { ... } }));
   * ```
   */
  public route(router: TypeweaverRouter<Record<string, RequestHandler>>): this;
  public route(
    prefix: string,
    router: TypeweaverRouter<Record<string, RequestHandler>>
  ): this;
  public route(
    prefixOrRouter: string | TypeweaverRouter<Record<string, RequestHandler>>,
    router?: TypeweaverRouter<Record<string, RequestHandler>>
  ): this {
    if (typeof prefixOrRouter === "string") {
      if (!router) {
        throw new Error("Router is required when mounting with a prefix");
      }
      return this.mountRouter(router, prefixOrRouter);
    }
    return this.mountRouter(prefixOrRouter);
  }

  /**
   * Universal request handler compatible with Fetch API runtimes.
   *
   * The entire pipeline works with `IHttpRequest`/`IHttpResponse`.
   * Conversion from/to Fetch API `Request`/`Response` happens only here, at the boundary.
   *
   * Middleware runs for all requests (including 404s and 405s).
   * HEAD requests automatically fall back to GET handlers with body stripped from the response.
   *
   * @example
   * ```typescript
   * // Bun
   * Bun.serve({ fetch: app.fetch, port: 3000 });
   *
   * // Deno
   * Deno.serve({ port: 3000 }, app.fetch);
   * ```
   */
  public fetch = async (request: Request): Promise<Response> => {
    try {
      const response = await this.processRequest(request);
      return this.adapter.toResponse(response);
    } catch (error) {
      if (error instanceof PayloadTooLargeError) {
        return this.adapter.toResponse({
          statusCode: 413,
          body: { code: "PAYLOAD_TOO_LARGE", message: error.message },
        });
      }
      if (error instanceof BodyParseError) {
        return this.adapter.toResponse({
          statusCode: 400,
          body: { code: "BAD_REQUEST", message: error.message },
        });
      }
      try {
        this.onError(error);
      } catch {
        /* Safety net must never throw */
      }
      return TypeweaverApp.createErrorResponse();
    }
  };

  private async processRequest(request: Request): Promise<IHttpResponse> {
    const url = new URL(request.url);
    const httpRequest = await this.adapter.toRequest(request, url);

    const ctx: ServerContext = {
      request: httpRequest,
      state: new Map(),
    };

    const matchingMiddleware = this.middlewares
      .filter(m => Router.matchesMiddlewarePath(m.path, httpRequest.path))
      .map(m => m.handler);

    const response = await executeMiddlewarePipeline(
      matchingMiddleware,
      ctx,
      () => this.resolveAndExecute(request.method, url.pathname, ctx)
    );

    return request.method.toUpperCase() === "HEAD"
      ? { ...response, body: undefined }
      : response;
  }

  /**
   * Match the route and execute the handler.
   * Called as the final handler in the middleware pipeline.
   */
  private async resolveAndExecute(
    method: string,
    pathname: string,
    ctx: ServerContext
  ): Promise<IHttpResponse> {
    const match = this.router.match(method, pathname);

    if (match) {
      const routeCtx = this.withPathParams(ctx, match.params);
      try {
        return await this.executeHandler(routeCtx, match.route);
      } catch (error) {
        return this.handleError(error, routeCtx, match.route);
      }
    }

    const pathMatch = this.router.matchPath(pathname);
    if (pathMatch) {
      return {
        statusCode: 405,
        header: { Allow: pathMatch.allowedMethods.join(", ") },
        body: { code: "METHOD_NOT_ALLOWED", message: "Method Not Allowed" },
      };
    }

    return {
      statusCode: 404,
      body: { code: "NOT_FOUND", message: "Not Found" },
    };
  }

  private withPathParams(
    ctx: ServerContext,
    params: Record<string, string>
  ): ServerContext {
    if (Object.keys(params).length === 0) return ctx;
    return { ...ctx, request: { ...ctx.request, param: params } };
  }

  private async executeHandler(
    ctx: ServerContext,
    route: RouteDefinition
  ): Promise<IHttpResponse> {
    const validatedRequest = route.routerConfig.validateRequests
      ? route.validator.validate(ctx.request)
      : ctx.request;

    return route.handler(validatedRequest, ctx);
  }

  /**
   * Handle errors using the route's configured error handlers.
   * Handler errors bubble up to the safety net in `fetch()`.
   */
  private handleError(
    error: unknown,
    ctx: ServerContext,
    route: RouteDefinition
  ): IHttpResponse | Promise<IHttpResponse> {
    const config = route.routerConfig;

    if (error instanceof RequestValidationError) {
      const handler = this.resolveErrorHandler<ValidationErrorHandler>(
        config.handleValidationErrors,
        TypeweaverApp.defaultValidationHandler
      );
      if (handler) return handler(error, ctx);
    }

    if (error instanceof HttpResponse) {
      const handler = this.resolveErrorHandler<HttpResponseErrorHandler>(
        config.handleHttpResponseErrors,
        TypeweaverApp.defaultHttpResponseHandler
      );
      if (handler) return handler(error, ctx);
    }

    const handler = this.resolveErrorHandler<UnknownErrorHandler>(
      config.handleUnknownErrors,
      this.defaultUnknownHandler
    );
    if (handler) return handler(error, ctx);

    throw error;
  }

  /**
   * Resolve an error handler option to a concrete handler function.
   */
  private resolveErrorHandler<T extends (...args: any[]) => any>(
    option: T | boolean | undefined,
    defaultHandler: T
  ): T | undefined {
    if (option === false) return undefined;
    if (option === true || option === undefined) return defaultHandler;
    return option;
  }

  private mountRouter(
    router: TypeweaverRouter<Record<string, RequestHandler>>,
    prefix?: string
  ): this {
    const normalizedPrefix = prefix?.replace(/\/+$/, "");
    for (const route of router.getRoutes()) {
      this.router.add({
        ...route,
        path: normalizedPrefix ? normalizedPrefix + route.path : route.path,
      });
    }
    return this;
  }

  private static sanitizeIssues(
    issues: readonly {
      readonly message: string;
      readonly path: PropertyKey[];
    }[]
  ): readonly { message: string; path: PropertyKey[] }[] | undefined {
    if (issues.length === 0) return undefined;
    return issues.map(({ message, path }) => ({ message, path }));
  }

  private static defaultValidationHandler: ValidationErrorHandler = (
    err
  ): IHttpResponse => {
    const issues: Record<string, unknown> = Object.create(null);

    const header = TypeweaverApp.sanitizeIssues(err.headerIssues);
    const body = TypeweaverApp.sanitizeIssues(err.bodyIssues);
    const query = TypeweaverApp.sanitizeIssues(err.queryIssues);
    const param = TypeweaverApp.sanitizeIssues(err.pathParamIssues);

    if (header) issues.header = header;
    if (body) issues.body = body;
    if (query) issues.query = query;
    if (param) issues.param = param;

    return {
      statusCode: 400,
      body: {
        code: "VALIDATION_ERROR",
        message: err.message,
        issues,
      },
    };
  };

  private static defaultHttpResponseHandler: HttpResponseErrorHandler = (
    err
  ): IHttpResponse => err;

  private readonly defaultUnknownHandler: UnknownErrorHandler = (
    error
  ): IHttpResponse => {
    try {
      this.onError(error);
    } catch {
      /* Observer must not break the pipeline */
    }
    return { statusCode: 500, body: TypeweaverApp.INTERNAL_SERVER_ERROR_BODY };
  };

  private static createErrorResponse(): Response {
    return new Response(
      JSON.stringify(TypeweaverApp.INTERNAL_SERVER_ERROR_BODY),
      {
        status: 500,
        headers: { "content-type": "application/json" },
      }
    );
  }
}
