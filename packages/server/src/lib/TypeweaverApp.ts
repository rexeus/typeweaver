/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import {
  HttpResponse,
  RequestValidationError,
} from "@rexeus/typeweaver-core";
import type { IHttpResponse } from "@rexeus/typeweaver-core";
import { FetchApiAdapter } from "./FetchApiAdapter";
import type { Middleware, MiddlewareEntry } from "./Middleware";
import { executeMiddlewarePipeline } from "./Middleware";
import {
  Router,
  type RouteDefinition,
  type HttpResponseErrorHandler,
  type ValidationErrorHandler,
  type UnknownErrorHandler,
} from "./Router";
import type { ServerContext } from "./ServerContext";
import type { TypeweaverRouter } from "./TypeweaverRouter";

/**
 * The main application class that provides routing, middleware, and
 * request handling — all using typeweaver's native `IHttpRequest`/`IHttpResponse` format.
 *
 * Exposes a single `fetch()` method compatible with Bun, Deno, Cloudflare Workers,
 * and adaptable to Node.js `http.createServer`.
 *
 * Internally, the entire pipeline operates on `IHttpRequest`/`IHttpResponse`.
 * Conversion from/to Fetch API `Request`/`Response` happens **only** at the boundary.
 *
 * Middleware is return-based: each middleware returns an `IHttpResponse`
 * instead of mutating shared state.
 *
 * @example
 * ```typescript
 * const app = new TypeweaverApp();
 *
 * // Global middleware
 * app.use(async (ctx, next) => {
 *   console.log(`${ctx.request.method} ${ctx.request.path}`);
 *   return next();
 * });
 *
 * // Path-scoped middleware (short-circuit)
 * app.use("/todos/*", async (ctx, next) => {
 *   const token = ctx.request.header?.["authorization"];
 *   if (!token) {
 *     return { statusCode: 401, body: { message: "Unauthorized" } };
 *   }
 *   return next();
 * });
 *
 * // Mount generated routers
 * app.route(new AccountRouter({ requestHandlers: { ... } }));
 * app.route(new TodoRouter({ requestHandlers: { ... } }));
 *
 * // Start
 * Bun.serve({ fetch: app.fetch, port: 3000 });
 * ```
 */
export class TypeweaverApp {
  private readonly router = new Router();
  private readonly middlewares: MiddlewareEntry[] = [];
  private readonly adapter = new FetchApiAdapter();

  /**
   * Register a global middleware that runs for all requests.
   */
  public use(middleware: Middleware): this;

  /**
   * Register a path-scoped middleware that runs only for matching paths.
   *
   * Supports wildcard patterns: `/todos/*` matches `/todos/123`, `/todos/123/subtodos`, etc.
   */
  public use(path: string, middleware: Middleware): this;

  public use(
    pathOrMiddleware: string | Middleware,
    middleware?: Middleware
  ): this {
    if (typeof pathOrMiddleware === "string") {
      this.middlewares.push({
        path: pathOrMiddleware,
        handler: middleware!,
      });
    } else {
      this.middlewares.push({
        path: undefined,
        handler: pathOrMiddleware,
      });
    }
    return this;
  }

  /**
   * Mount a generated `TypeweaverRouter` instance.
   *
   * Registers all routes from the router into the app.
   * Multiple routers can be mounted on the same app.
   */
  public route(router: TypeweaverRouter<any>): this {
    for (const route of router.getRoutes()) {
      this.router.add(route);
    }
    return this;
  }

  /**
   * Universal request handler compatible with Fetch API runtimes.
   *
   * The entire pipeline works with `IHttpRequest`/`IHttpResponse`.
   * Conversion from/to Fetch API `Request`/`Response` happens only here, at the boundary.
   *
   * @example
   * ```typescript
   * // Bun
   * Bun.serve({ fetch: app.fetch, port: 3000 });
   *
   * // Deno
   * Deno.serve({ port: 3000 }, app.fetch);
   * ```
   */
  public fetch = async (request: Request): Promise<Response> => {
    // --- BOUNDARY IN: Fetch API Request → IHttpRequest ---
    const url = new URL(request.url);
    const match = this.router.match(request.method, url.pathname);

    if (!match) {
      return this.adapter.toResponse({
        statusCode: 404,
        body: { code: "NOT_FOUND", message: "Not Found" },
      });
    }

    const httpRequest = await this.adapter.toRequest(request, match.params);

    // --- INTERNAL: Everything is IHttpRequest/IHttpResponse ---
    const ctx: ServerContext = {
      request: httpRequest,
      state: new Map(),
    };

    let response: IHttpResponse;

    try {
      // Collect matching middleware
      const matchingMiddleware = this.middlewares
        .filter(m => Router.matchesMiddlewarePath(m.path, httpRequest.path))
        .map(m => m.handler);

      // Execute middleware pipeline → handler
      response = await executeMiddlewarePipeline(
        matchingMiddleware,
        ctx,
        () => this.executeHandler(ctx, match.route)
      );
    } catch (error) {
      response = await this.handleError(error, ctx, match.route);
    }

    // --- BOUNDARY OUT: IHttpResponse → Fetch API Response ---
    return this.adapter.toResponse(response);
  };

  /**
   * Execute the route handler with optional validation.
   */
  private async executeHandler(
    ctx: ServerContext,
    route: RouteDefinition
  ): Promise<IHttpResponse> {
    // Validate request if enabled
    const validatedRequest = route.routerConfig.validateRequests
      ? route.validator.validate(ctx.request)
      : ctx.request;

    // Call handler — returns IHttpResponse directly
    return route.handler(validatedRequest, ctx);
  }

  /**
   * Handle errors using the server's configured error handlers.
   */
  private async handleError(
    error: unknown,
    ctx: ServerContext,
    route: RouteDefinition
  ): Promise<IHttpResponse> {
    const config = route.routerConfig;

    // Handle validation errors
    if (error instanceof RequestValidationError) {
      const handler = this.resolveErrorHandler<ValidationErrorHandler>(
        config.handleValidationErrors,
        (err): IHttpResponse => ({
          statusCode: 400,
          body: {
            code: "VALIDATION_ERROR",
            message: err.message,
            issues: {
              header: err.headerIssues,
              body: err.bodyIssues,
              query: err.queryIssues,
              param: err.pathParamIssues,
            },
          },
        })
      );
      if (handler) {
        try {
          return await handler(error, ctx);
        } catch {
          // Handler failed, fall through
        }
      }
    }

    // Handle HTTP response errors (thrown HttpResponse instances)
    if (error instanceof HttpResponse) {
      const handler = this.resolveErrorHandler<HttpResponseErrorHandler>(
        config.handleHttpResponseErrors,
        (err): IHttpResponse => err
      );
      if (handler) {
        try {
          return await handler(error, ctx);
        } catch {
          // Handler failed, fall through
        }
      }
    }

    // Handle unknown errors
    const handler = this.resolveErrorHandler<UnknownErrorHandler>(
      config.handleUnknownErrors,
      (): IHttpResponse => ({
        statusCode: 500,
        body: {
          code: "INTERNAL_SERVER_ERROR",
          message: "An unexpected error occurred.",
        },
      })
    );
    if (handler) {
      try {
        return await handler(error, ctx);
      } catch {
        // Handler also failed
      }
    }

    // Last resort
    return {
      statusCode: 500,
      body: {
        code: "INTERNAL_SERVER_ERROR",
        message: "An unexpected error occurred.",
      },
    };
  }

  /**
   * Resolve an error handler option to a concrete handler function.
   */
  private resolveErrorHandler<T extends (...args: any[]) => any>(
    option: T | boolean | undefined,
    defaultHandler: T
  ): T | undefined {
    if (option === false) return undefined;
    if (option === true || option === undefined) return defaultHandler;
    return option;
  }
}
