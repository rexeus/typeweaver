/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type { IncomingMessage, ServerResponse, Server } from "node:http";
import type {
  HttpMethod,
  IHttpRequest,
  IHttpResponse,
  IHttpHeader,
} from "@rexeus/typeweaver-core";
import type { TypeweaverRouter } from "./TypeweaverRouter";

/**
 * Middleware that works directly with IHttpRequest/IHttpResponse.
 * No framework context — just request in, response out.
 *
 * @param request - The incoming request
 * @param next - Call to proceed to the next middleware or route handler
 * @returns The response
 */
export type Middleware = (
  request: IHttpRequest,
  next: () => Promise<IHttpResponse>
) => Promise<IHttpResponse>;

/**
 * Lifecycle hooks for the TypeweaverServer.
 */
export type TypeweaverServerLifecycleHooks = {
  onStarted?: (info: { port: number; hostname: string }) => void;
  onStopping?: () => void | Promise<void>;
};

/**
 * Health check configuration.
 */
export type HealthCheckConfig = {
  /** @default "/health" */
  path?: string;
  /** Custom check function. Throw to signal unhealthy. */
  check?: () => Promise<Record<string, unknown>> | Record<string, unknown>;
};

/**
 * Configuration options for the TypeweaverServer.
 */
export type TypeweaverServerOptions = {
  /** @default 3000 */
  port?: number;
  /** @default "0.0.0.0" */
  hostname?: string;
  /**
   * Base path prefix for all routes.
   * @example "/api/v1"
   */
  basePath?: string;
  /** @default true */
  healthCheck?: HealthCheckConfig | boolean;
  /** @default true */
  gracefulShutdown?: boolean;
  /** @default 10000 */
  shutdownTimeout?: number;
  /** @default true */
  requestId?: boolean;
  hooks?: TypeweaverServerLifecycleHooks;
};

/**
 * A mounted router entry.
 */
type MountedRouter = {
  prefix: string;
  router: TypeweaverRouter<any>;
};

/**
 * Zero-dependency HTTP server for typeweaver-generated routers.
 *
 * Works natively with IHttpRequest/IHttpResponse — no adapters, no mapping.
 * Incoming HTTP requests are parsed directly into IHttpRequest.
 * Outgoing IHttpResponse is written directly to the wire.
 *
 * @example Node.js
 * ```ts
 * const server = new TypeweaverServer({ port: 3000, basePath: "/api/v1" });
 * server.route("/", new TodoRouter({ requestHandlers: new TodoHandlers() }));
 * await server.start();
 * ```
 *
 * @example Deno
 * ```ts
 * const server = new TypeweaverServer({ basePath: "/api/v1" });
 * server.route("/", new TodoRouter({ requestHandlers: new TodoHandlers() }));
 * Deno.serve({ port: 3000 }, server.fetch);
 * ```
 */
export class TypeweaverServer {
  private readonly options: Required<
    Pick<
      TypeweaverServerOptions,
      | "port"
      | "hostname"
      | "gracefulShutdown"
      | "shutdownTimeout"
      | "requestId"
    >
  > &
    TypeweaverServerOptions;

  private readonly routers: MountedRouter[] = [];
  private readonly middlewares: Middleware[] = [];
  private httpServer: Server | undefined;
  private isShuttingDown = false;
  private signalHandlers: Array<{ signal: string; handler: () => void }> = [];

  public constructor(options: TypeweaverServerOptions = {}) {
    this.options = {
      port: 3000,
      hostname: "0.0.0.0",
      gracefulShutdown: true,
      shutdownTimeout: 10_000,
      requestId: true,
      ...options,
    };
  }

  /**
   * Register middleware.
   * Middleware executes in registration order, before route handlers.
   */
  public use(middleware: Middleware): this {
    this.middlewares.push(middleware);
    return this;
  }

  /**
   * Mount a TypeweaverRouter at a path prefix.
   */
  public route(prefix: string, router: TypeweaverRouter<any>): this {
    this.routers.push({
      prefix: this.normalizePrefix(prefix),
      router,
    });
    return this;
  }

  /**
   * Start the server using Node.js built-in `http` module.
   * Zero external dependencies — uses only `node:http`.
   */
  public async start(): Promise<void> {
    if (this.httpServer) {
      throw new Error("Server is already running.");
    }

    const { port, hostname } = this.options;
    const http = await import("node:http");

    this.httpServer = http.createServer(
      (req: IncomingMessage, res: ServerResponse) => {
        this.handleNodeRequest(req, res);
      }
    );

    await new Promise<void>((resolve, reject) => {
      this.httpServer!.on("error", reject);
      this.httpServer!.listen(port, hostname, () => {
        this.httpServer!.removeListener("error", reject);
        resolve();
      });
    });

    if (this.options.gracefulShutdown) {
      this.registerSignalHandlers();
    }

    this.options.hooks?.onStarted?.({ port, hostname });
  }

  /**
   * Stop the server gracefully.
   */
  public async stop(): Promise<void> {
    if (!this.httpServer || this.isShuttingDown) return;

    this.isShuttingDown = true;
    await this.options.hooks?.onStopping?.();

    await new Promise<void>(resolve => {
      const timeout = setTimeout(resolve, this.options.shutdownTimeout);
      this.httpServer!.close(() => {
        clearTimeout(timeout);
        resolve();
      });
    });

    this.removeSignalHandlers();
    this.httpServer = undefined;
    this.isShuttingDown = false;
  }

  /**
   * Fetch API handler for Deno/Bun.
   * Parses Request → IHttpRequest, routes, returns IHttpResponse → Response.
   */
  public get fetch(): (request: Request) => Promise<Response> {
    return async (request: Request): Promise<Response> => {
      const httpRequest = await this.parseFetchRequest(request);
      const httpResponse = await this.dispatch(httpRequest);
      return this.toFetchResponse(httpResponse);
    };
  }

  public get isRunning(): boolean {
    return this.httpServer !== undefined && !this.isShuttingDown;
  }

  // ── Node.js HTTP handling ────────────────────────────────────────

  private handleNodeRequest(
    req: IncomingMessage,
    res: ServerResponse
  ): void {
    this.parseNodeRequest(req)
      .then(httpRequest => this.dispatch(httpRequest))
      .then(httpResponse => this.writeNodeResponse(res, httpResponse))
      .catch(() => {
        if (!res.headersSent) {
          res.writeHead(500, { "Content-Type": "application/json" });
          res.end(
            JSON.stringify({
              code: "INTERNAL_SERVER_ERROR",
              message: "An unexpected error occurred.",
            })
          );
        }
      });
  }

  /**
   * Parse Node.js IncomingMessage directly into IHttpRequest.
   * No intermediate Fetch Request — zero-copy path.
   */
  private async parseNodeRequest(req: IncomingMessage): Promise<IHttpRequest> {
    const url = new URL(req.url ?? "/", `http://${req.headers.host ?? "localhost"}`);

    return {
      method: (req.method ?? "GET").toUpperCase() as HttpMethod,
      path: url.pathname,
      header: this.parseNodeHeaders(req),
      query: this.parseQueryParams(url),
      body: await this.parseNodeBody(req),
    };
  }

  private parseNodeHeaders(req: IncomingMessage): IHttpHeader {
    const result: Record<string, string | string[]> = {};

    for (const [key, value] of Object.entries(req.headers)) {
      if (value === undefined) continue;
      result[key] = value;
    }

    return Object.keys(result).length > 0 ? result : undefined;
  }

  private parseNodeBody(req: IncomingMessage): Promise<unknown> {
    return new Promise((resolve, reject) => {
      const chunks: Buffer[] = [];

      req.on("data", (chunk: Buffer) => chunks.push(chunk));
      req.on("error", reject);
      req.on("end", () => {
        if (chunks.length === 0) {
          resolve(undefined);
          return;
        }

        const raw = Buffer.concat(chunks).toString("utf-8");
        const contentType = req.headers["content-type"] ?? "";

        if (contentType.includes("application/json")) {
          try {
            resolve(JSON.parse(raw));
          } catch {
            resolve(undefined);
          }
          return;
        }

        if (contentType.includes("application/x-www-form-urlencoded")) {
          const form = new URLSearchParams(raw);
          const obj: Record<string, string | string[]> = {};
          form.forEach((value, key) => {
            const existing = obj[key];
            if (existing) {
              obj[key] = Array.isArray(existing)
                ? [...existing, value]
                : [existing, value];
            } else {
              obj[key] = value;
            }
          });
          resolve(obj);
          return;
        }

        resolve(raw || undefined);
      });
    });
  }

  private writeNodeResponse(res: ServerResponse, httpResponse: IHttpResponse): void {
    const { statusCode, header, body } = httpResponse;

    if (header) {
      for (const [key, value] of Object.entries(header)) {
        if (value !== undefined) {
          res.setHeader(key, value);
        }
      }
    }

    if (body === undefined || body === null) {
      res.writeHead(statusCode);
      res.end();
      return;
    }

    if (typeof body === "string") {
      if (!res.hasHeader("content-type")) {
        res.setHeader("Content-Type", "text/plain; charset=utf-8");
      }
      res.writeHead(statusCode);
      res.end(body);
      return;
    }

    // JSON body
    if (!res.hasHeader("content-type")) {
      res.setHeader("Content-Type", "application/json; charset=utf-8");
    }
    const jsonBody = JSON.stringify(body);
    res.writeHead(statusCode);
    res.end(jsonBody);
  }

  // ── Fetch API handling (Deno/Bun) ────────────────────────────────

  private async parseFetchRequest(request: Request): Promise<IHttpRequest> {
    const url = new URL(request.url);

    return {
      method: request.method.toUpperCase() as HttpMethod,
      path: url.pathname,
      header: this.parseFetchHeaders(request.headers),
      query: this.parseQueryParams(url),
      body: await this.parseFetchBody(request),
    };
  }

  private parseFetchHeaders(headers: Headers): IHttpHeader {
    const result: Record<string, string | string[]> = {};
    headers.forEach((value, key) => {
      if (!value) return;
      const existing = result[key];
      if (existing) {
        result[key] = Array.isArray(existing)
          ? [...existing, value]
          : [existing, value];
      } else {
        result[key] = value;
      }
    });
    return Object.keys(result).length > 0 ? result : undefined;
  }

  private async parseFetchBody(request: Request): Promise<unknown> {
    if (!request.body) return undefined;

    const contentType = request.headers.get("content-type") ?? "";

    if (contentType.includes("application/json")) {
      try {
        return await request.json();
      } catch {
        return undefined;
      }
    }

    if (contentType.includes("text/")) {
      return await request.text();
    }

    if (contentType.includes("application/x-www-form-urlencoded")) {
      const text = await request.text();
      const form = new URLSearchParams(text);
      const obj: Record<string, string | string[]> = {};
      form.forEach((value, key) => {
        const existing = obj[key];
        if (existing) {
          obj[key] = Array.isArray(existing)
            ? [...existing, value]
            : [existing, value];
        } else {
          obj[key] = value;
        }
      });
      return obj;
    }

    const raw = await request.text();
    return raw || undefined;
  }

  private toFetchResponse(httpResponse: IHttpResponse): Response {
    const { statusCode, body, header } = httpResponse;

    const headers = new Headers();
    if (header) {
      for (const [key, value] of Object.entries(header)) {
        if (value === undefined) continue;
        if (Array.isArray(value)) {
          for (const v of value) {
            headers.append(key, v);
          }
        } else {
          headers.set(key, String(value));
        }
      }
    }

    let responseBody: string | null = null;
    if (body !== undefined && body !== null) {
      if (typeof body === "string") {
        responseBody = body;
        if (!headers.has("content-type")) {
          headers.set("Content-Type", "text/plain; charset=utf-8");
        }
      } else {
        responseBody = JSON.stringify(body);
        if (!headers.has("content-type")) {
          headers.set("Content-Type", "application/json; charset=utf-8");
        }
      }
    }

    return new Response(responseBody, { status: statusCode, headers });
  }

  // ── Shared query parsing ──────────────────────────────────────────

  private parseQueryParams(
    url: URL
  ): Record<string, string | string[]> | undefined {
    const result: Record<string, string | string[]> = {};
    url.searchParams.forEach((value, key) => {
      const existing = result[key];
      if (existing) {
        result[key] = Array.isArray(existing)
          ? [...existing, value]
          : [existing, value];
      } else {
        result[key] = value;
      }
    });
    return Object.keys(result).length > 0 ? result : undefined;
  }

  // ── Request dispatching ───────────────────────────────────────────

  /**
   * Dispatch a request through middleware → routers.
   * All logic operates on IHttpRequest/IHttpResponse — no framework types.
   */
  private async dispatch(rawRequest: IHttpRequest): Promise<IHttpResponse> {
    // Apply basePath stripping
    const request = this.applyBasePath(rawRequest);
    if (!request) {
      return { statusCode: 404, body: { message: "Not Found" } };
    }

    // Apply built-in middleware (request ID)
    const enrichedRequest = this.applyBuiltInMiddleware(request);

    // Build the middleware chain → router dispatch
    const routerDispatch = () => this.dispatchToRouters(enrichedRequest);

    // Execute middleware chain
    const chain = this.buildMiddlewareChain(
      enrichedRequest,
      this.middlewares,
      routerDispatch
    );

    let response = await chain();

    // Apply built-in response enrichment (request ID header)
    response = this.enrichResponse(enrichedRequest, response);

    return response;
  }

  private applyBasePath(request: IHttpRequest): IHttpRequest | undefined {
    const basePath = this.options.basePath;
    if (!basePath) return request;

    const normalized = basePath.endsWith("/") ? basePath.slice(0, -1) : basePath;
    if (!request.path.startsWith(normalized)) {
      return undefined;
    }

    const stripped = request.path.slice(normalized.length) || "/";
    return { ...request, path: stripped };
  }

  private applyBuiltInMiddleware(request: IHttpRequest): IHttpRequest {
    if (!this.options.requestId) return request;

    const existingId =
      request.header && typeof request.header === "object"
        ? (request.header as Record<string, string | string[]>)[
            "x-request-id"
          ]
        : undefined;

    if (existingId) return request;

    // Attach a generated request ID to the request header
    const requestId = crypto.randomUUID();
    const currentHeader = (request.header as Record<string, string | string[]>) ?? {};
    return {
      ...request,
      header: { ...currentHeader, "x-request-id": requestId },
    };
  }

  private enrichResponse(
    request: IHttpRequest,
    response: IHttpResponse
  ): IHttpResponse {
    if (!this.options.requestId) return response;

    const requestId =
      request.header && typeof request.header === "object"
        ? (request.header as Record<string, string | string[]>)[
            "x-request-id"
          ]
        : undefined;

    if (!requestId) return response;

    const currentHeader = (response.header as Record<string, string | string[]>) ?? {};
    return {
      ...response,
      header: { ...currentHeader, "X-Request-Id": requestId },
    };
  }

  private buildMiddlewareChain(
    request: IHttpRequest,
    middlewares: Middleware[],
    final: () => Promise<IHttpResponse>
  ): () => Promise<IHttpResponse> {
    let index = middlewares.length;
    let next = final;

    while (index > 0) {
      index--;
      const middleware = middlewares[index]!;
      const currentNext = next;
      next = () => middleware(request, currentNext);
    }

    return next;
  }

  private async dispatchToRouters(
    request: IHttpRequest
  ): Promise<IHttpResponse> {
    // Check health endpoint first
    const healthResponse = this.checkHealthEndpoint(request);
    if (healthResponse) return healthResponse;

    // Try each mounted router
    for (const { prefix, router } of this.routers) {
      const routerRequest = this.stripPrefix(request, prefix);
      if (!routerRequest) continue;

      const response = await router.handle(routerRequest);
      if (response) return response;
    }

    return { statusCode: 404, body: { message: "Not Found" } };
  }

  private stripPrefix(
    request: IHttpRequest,
    prefix: string
  ): IHttpRequest | undefined {
    if (prefix === "/" || prefix === "") return request;

    if (!request.path.startsWith(prefix)) return undefined;

    const stripped = request.path.slice(prefix.length) || "/";
    return { ...request, path: stripped };
  }

  private checkHealthEndpoint(
    request: IHttpRequest
  ): IHttpResponse | Promise<IHttpResponse> | undefined {
    const { healthCheck } = this.options;
    if (healthCheck === false) return undefined;

    const config: HealthCheckConfig =
      healthCheck === true || healthCheck === undefined ? {} : healthCheck;

    const healthPath = config.path ?? "/health";

    if (request.method !== "GET" || request.path !== healthPath) {
      return undefined;
    }

    const checkFn = config.check ?? (() => ({ status: "ok" }));

    try {
      const result = checkFn();
      if (result && typeof (result as Promise<unknown>).then === "function") {
        return (result as Promise<Record<string, unknown>>).then(
          data => ({ statusCode: 200, body: data }),
          error => ({
            statusCode: 503,
            body: {
              status: "error",
              message:
                error instanceof Error ? error.message : "Health check failed",
            },
          })
        );
      }
      return { statusCode: 200, body: result as Record<string, unknown> };
    } catch (error) {
      return {
        statusCode: 503,
        body: {
          status: "error",
          message:
            error instanceof Error ? error.message : "Health check failed",
        },
      };
    }
  }

  // ── Helpers ───────────────────────────────────────────────────────

  private normalizePrefix(prefix: string): string {
    if (prefix === "/" || prefix === "") return "/";
    return prefix.endsWith("/") ? prefix.slice(0, -1) : prefix;
  }

  private registerSignalHandlers(): void {
    if (typeof process === "undefined" || !process.on) return;

    const shutdown = () => void this.stop();

    for (const signal of ["SIGTERM", "SIGINT"] as const) {
      this.signalHandlers.push({ signal, handler: shutdown });
      process.on(signal, shutdown);
    }
  }

  private removeSignalHandlers(): void {
    if (typeof process === "undefined" || !process.removeListener) return;

    for (const { signal, handler } of this.signalHandlers) {
      process.removeListener(signal, handler);
    }
    this.signalHandlers = [];
  }
}
