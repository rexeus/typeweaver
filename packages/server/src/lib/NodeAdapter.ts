/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type { IncomingMessage, ServerResponse } from "node:http";
import type { TypeweaverApp } from "./TypeweaverApp";

/**
 * Adapts a `TypeweaverApp` to Node.js `http.createServer`.
 *
 * Converts `IncomingMessage` to a Fetch API `Request`, calls `app.fetch()`,
 * and writes the `Response` back to `ServerResponse`.
 *
 * @example
 * ```typescript
 * import { createServer } from "node:http";
 * import { nodeAdapter } from "./generated/lib/server";
 * import app from "./server";
 *
 * createServer(nodeAdapter(app)).listen(3000);
 * ```
 */
export function nodeAdapter(
  app: TypeweaverApp
): (req: IncomingMessage, res: ServerResponse) => void {
  return (req, res) => {
    void handleRequest(app, req, res);
  };
}

async function handleRequest(
  app: TypeweaverApp,
  req: IncomingMessage,
  res: ServerResponse
): Promise<void> {
  try {
    const url = new URL(req.url ?? "/", `http://${req.headers.host}`);
    const isBodyless = req.method === "GET" || req.method === "HEAD";
    const body = isBodyless ? undefined : await collectBody(req);

    const request = new Request(url, {
      method: req.method,
      headers: req.headers as Record<string, string>,
      body,
    });

    const response = await app.fetch(request);

    response.headers.forEach((value, key) => {
      res.setHeader(key, value);
    });
    res.writeHead(response.status);
    res.end(await response.text());
  } catch (error) {
    console.error(error);
    if (!res.headersSent) {
      res.writeHead(500, { "content-type": "application/json" });
    }
    res.end(
      JSON.stringify({
        code: "INTERNAL_SERVER_ERROR",
        message: "An unexpected error occurred",
      })
    );
  }
}

function collectBody(req: IncomingMessage): Promise<string> {
  return new Promise<string>((resolve, reject) => {
    let data = "";
    req.on("data", (chunk: Buffer) => (data += chunk));
    req.on("end", () => resolve(data));
    req.on("error", reject);
  });
}
