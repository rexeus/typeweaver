/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type { ServerContext } from "./ServerContext";

/**
 * A middleware function that processes requests in the pipeline.
 *
 * Follows the onion model: call `next()` to pass control to the next
 * middleware or handler, then execute post-processing logic after `next()` returns.
 *
 * To short-circuit the pipeline, set `ctx.response` and return without calling `next()`.
 *
 * @example
 * ```typescript
 * const logger: Middleware = async (ctx, next) => {
 *   const start = Date.now();
 *   await next();
 *   console.log(`${ctx.request.method} ${ctx.request.path} -> ${ctx.response?.statusCode} (${Date.now() - start}ms)`);
 * };
 * ```
 */
export type Middleware = (
  ctx: ServerContext,
  next: () => Promise<void>
) => Promise<void>;

/**
 * Internal representation of a registered middleware with optional path scope.
 */
export type MiddlewareEntry = {
  /** Path pattern to match. `undefined` means global (matches all paths). */
  path: string | undefined;
  /** The middleware function. */
  handler: Middleware;
};

/**
 * Executes a middleware pipeline in onion order.
 *
 * Each middleware receives a `next()` function that invokes the next
 * middleware in the chain. The final `next()` calls the provided `finalHandler`.
 *
 * @param middlewares - Ordered list of middleware functions to execute
 * @param ctx - The server context shared across the pipeline
 * @param finalHandler - The handler to execute after all middleware
 */
export async function executeMiddlewarePipeline(
  middlewares: Middleware[],
  ctx: ServerContext,
  finalHandler: () => Promise<void>
): Promise<void> {
  let index = 0;

  const next = async (): Promise<void> => {
    if (index < middlewares.length) {
      const middleware = middlewares[index++]!;
      await middleware(ctx, next);
    } else {
      await finalHandler();
    }
  };

  await next();
}
