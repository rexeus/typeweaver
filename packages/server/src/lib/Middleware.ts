/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import type { IHttpResponse } from "@rexeus/typeweaver-core";
import type { ServerContext } from "./ServerContext";

/**
 * A middleware function that processes requests in the pipeline.
 *
 * Follows a return-based onion model: call `next()` to pass control to the next
 * middleware or handler and receive the response, then return it (optionally modified).
 *
 * When middleware provides state, it passes the state object to `next(state)`.
 * The pipeline merges this state into `ctx.state` before continuing to the
 * next middleware, guaranteeing downstream consumers can read it.
 *
 * To short-circuit the pipeline, return a response without calling `next()`.
 */
export type Middleware = (
  ctx: ServerContext,
  next: (state?: Record<string, unknown>) => Promise<IHttpResponse>
) => Promise<IHttpResponse>;

/**
 * Executes a middleware pipeline in onion order (return-based).
 *
 * Each middleware receives a `next()` function that optionally accepts a state
 * object. When state is provided, it is merged into `ctx.state` before invoking
 * the next middleware in the chain. The final `next()` calls the provided
 * `finalHandler`.
 *
 * @param middlewares - Ordered list of middleware functions to execute
 * @param ctx - The server context shared across the pipeline
 * @param finalHandler - The handler to execute after all middleware
 * @returns The response produced by the pipeline
 */
export async function executeMiddlewarePipeline(
  middlewares: Middleware[],
  ctx: ServerContext,
  finalHandler: () => Promise<IHttpResponse>
): Promise<IHttpResponse> {
  let index = 0;

  const advance = async (): Promise<IHttpResponse> => {
    if (index < middlewares.length) {
      const currentIndex = index++;
      let called = false;

      return middlewares[currentIndex]!(ctx, async (state) => {
        if (called) {
          throw new Error("next() called multiple times");
        }
        called = true;

        if (state) {
          ctx.state.merge(state);
        }

        return advance();
      });
    }

    return finalHandler();
  };

  return advance();
}
