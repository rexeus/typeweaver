/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import { Hono } from "hono";
import type { Env, Schema } from "hono/types";

/**
 * Lifecycle hooks for the TypeweaverServer.
 */
export type TypeweaverServerLifecycleHooks = {
  /**
   * Called after the server has started listening.
   * @param info - Server address information
   */
  onStarted?: (info: { port: number; hostname: string }) => void;

  /**
   * Called when the server begins shutting down.
   * Use this for cleanup (closing DB connections, flushing logs, etc.).
   */
  onStopping?: () => void | Promise<void>;
};

/**
 * Health check configuration.
 */
export type HealthCheckConfig = {
  /**
   * The path for the health check endpoint.
   * @default "/health"
   */
  path?: string;

  /**
   * Custom health check handler.
   * Return an object to be serialized as JSON, or throw to signal unhealthy.
   * @default Returns `{ status: "ok" }`
   */
  check?: () => Promise<Record<string, unknown>> | Record<string, unknown>;
};

/**
 * Configuration options for the TypeweaverServer.
 */
export type TypeweaverServerOptions = {
  /**
   * Port to listen on.
   * @default 3000
   */
  port?: number;

  /**
   * Hostname to bind to.
   * @default "0.0.0.0"
   */
  hostname?: string;

  /**
   * Base path prefix for all routes.
   * When set, all routers are mounted under this prefix.
   * @example "/api/v1"
   */
  basePath?: string;

  /**
   * Enable health check endpoint.
   * - `true`: Enable with defaults (`/health` returning `{ status: "ok" }`)
   * - `false`: Disable health check
   * - `object`: Enable with custom configuration
   * @default true
   */
  healthCheck?: HealthCheckConfig | boolean;

  /**
   * Enable graceful shutdown on SIGTERM and SIGINT signals.
   * @default true
   */
  gracefulShutdown?: boolean;

  /**
   * Timeout in milliseconds to wait for in-flight requests during graceful shutdown.
   * After this timeout, the server will force-close.
   * @default 10000
   */
  shutdownTimeout?: number;

  /**
   * Enable automatic X-Request-Id header generation.
   * When enabled, each request receives a unique ID via the `X-Request-Id` response header.
   * If the incoming request already has an `X-Request-Id` header, it is preserved.
   * @default true
   */
  requestId?: boolean;

  /**
   * Lifecycle hooks for server events.
   */
  hooks?: TypeweaverServerLifecycleHooks;
};

/**
 * Production-ready HTTP server for typeweaver-generated Hono routers.
 *
 * Composes multiple TypeweaverHono routers into a single Hono application
 * with production features:
 * - Health check endpoint
 * - Graceful shutdown (SIGTERM/SIGINT)
 * - Request ID generation
 * - Base path / prefix support
 * - Multi-runtime support (Node.js, Deno, Bun)
 *
 * @example
 * ```ts
 * const server = new TypeweaverServer({
 *   port: 3000,
 *   basePath: "/api/v1",
 * });
 *
 * server.route("/", new TodoHono({ requestHandlers: new TodoHandlers() }));
 * server.route("/", new AuthHono({ requestHandlers: new AuthHandlers() }));
 *
 * await server.start();
 * ```
 */
export class TypeweaverServer<
  HonoEnv extends Env = Env,
  HonoSchema extends Schema = Schema,
  HonoBasePath extends string = "/",
> {
  /**
   * The underlying Hono application instance.
   * Use this to add custom middleware before calling `start()`.
   */
  public readonly app: Hono<HonoEnv, HonoSchema, HonoBasePath>;

  private readonly options: Required<
    Pick<
      TypeweaverServerOptions,
      | "port"
      | "hostname"
      | "gracefulShutdown"
      | "shutdownTimeout"
      | "requestId"
    >
  > &
    TypeweaverServerOptions;

  private server: { close: (callback?: (err?: Error) => void) => unknown } | undefined;
  private isShuttingDown = false;
  private signalHandlers: Array<{ signal: string; handler: () => void }> = [];

  public constructor(options: TypeweaverServerOptions = {}) {
    this.options = {
      port: 3000,
      hostname: "0.0.0.0",
      gracefulShutdown: true,
      shutdownTimeout: 10_000,
      requestId: true,
      ...options,
    };

    this.app = new Hono() as Hono<HonoEnv, HonoSchema, HonoBasePath>;

    this.setupMiddleware();
    this.setupHealthCheck();
  }

  /**
   * Mount a Hono router (typically a generated TypeweaverHono instance) onto the server.
   *
   * @param path - The path prefix for the router
   * @param router - The Hono router instance to mount
   * @returns this (for chaining)
   */
  public route<SubPath extends string>(
    path: SubPath,
    router: Hono<any, any, any>
  ): this {
    this.app.route(path, router);
    return this;
  }

  /**
   * Start the server using `@hono/node-server`.
   *
   * For Deno/Bun, use the `fetch` property directly:
   * - Deno: `Deno.serve({ port: 3000 }, server.fetch)`
   * - Bun: `Bun.serve({ port: 3000, fetch: server.fetch })`
   */
  public async start(): Promise<void> {
    if (this.server) {
      throw new Error("Server is already running.");
    }

    const { port, hostname } = this.options;

    // Dynamically import @hono/node-server to keep it optional
    const { serve } = await import("@hono/node-server");

    const rootApp = this.buildRootApp();

    this.server = serve({
      fetch: rootApp.fetch,
      port,
      hostname,
    });

    if (this.options.gracefulShutdown) {
      this.registerSignalHandlers();
    }

    this.options.hooks?.onStarted?.({ port, hostname });
  }

  /**
   * Stop the server gracefully.
   * Waits for in-flight requests to complete up to `shutdownTimeout`.
   */
  public async stop(): Promise<void> {
    if (!this.server || this.isShuttingDown) {
      return;
    }

    this.isShuttingDown = true;

    await this.options.hooks?.onStopping?.();

    await this.closeServer();

    this.removeSignalHandlers();
    this.server = undefined;
    this.isShuttingDown = false;
  }

  /**
   * The Fetch API handler for the server.
   * Use this with Deno.serve() or Bun.serve().
   */
  public get fetch(): (request: Request) => Response | Promise<Response> {
    const rootApp = this.buildRootApp();
    return rootApp.fetch;
  }

  /**
   * Whether the server is currently running.
   */
  public get isRunning(): boolean {
    return this.server !== undefined && !this.isShuttingDown;
  }

  private buildRootApp(): Hono {
    if (this.options.basePath) {
      const root = new Hono();
      root.route(this.options.basePath, this.app as unknown as Hono);
      return root;
    }

    return this.app as unknown as Hono;
  }

  private setupMiddleware(): void {
    if (this.options.requestId) {
      this.app.use("*", async (c, next) => {
        const existingId = c.req.header("x-request-id");
        const requestId = existingId ?? crypto.randomUUID();

        c.header("X-Request-Id", requestId);
        await next();
      });
    }
  }

  private setupHealthCheck(): void {
    const { healthCheck } = this.options;

    if (healthCheck === false) {
      return;
    }

    const config: HealthCheckConfig =
      healthCheck === true || healthCheck === undefined ? {} : healthCheck;

    const healthPath = config.path ?? "/health";
    const checkFn = config.check ?? (() => ({ status: "ok" }));

    this.app.get(healthPath, async c => {
      try {
        const result = await checkFn();
        return c.json(result, 200);
      } catch (error) {
        const message =
          error instanceof Error ? error.message : "Health check failed";
        return c.json({ status: "error", message }, 503);
      }
    });
  }

  private registerSignalHandlers(): void {
    const shutdown = () => {
      void this.stop();
    };

    for (const signal of ["SIGTERM", "SIGINT"] as const) {
      const handler = shutdown;
      this.signalHandlers.push({ signal, handler });
      process.on(signal, handler);
    }
  }

  private removeSignalHandlers(): void {
    for (const { signal, handler } of this.signalHandlers) {
      process.removeListener(signal, handler);
    }
    this.signalHandlers = [];
  }

  private async closeServer(): Promise<void> {
    if (!this.server) return;

    return new Promise<void>(resolve => {
      const timeout = setTimeout(() => {
        resolve();
      }, this.options.shutdownTimeout);

      this.server!.close((err?: Error) => {
        clearTimeout(timeout);
        // Resolve even on error - we're shutting down regardless
        resolve();
      });
    });
  }
}
