/**
 * This file was automatically generated by typeweaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 *
 * @generated by @rexeus/typeweaver
 */

import { Hono } from "hono";
import type { MiddlewareHandler } from "hono/types";

/**
 * Lifecycle hooks for the TypeweaverServer.
 */
export type TypeweaverServerLifecycleHooks = {
  /**
   * Called after the server has started listening.
   * @param info - Server address information
   */
  onStarted?: (info: { port: number; hostname: string }) => void;

  /**
   * Called when the server begins shutting down.
   * Use this for cleanup (closing DB connections, flushing logs, etc.).
   */
  onStopping?: () => void | Promise<void>;
};

/**
 * Health check configuration.
 */
export type HealthCheckConfig = {
  /**
   * The path for the health check endpoint.
   * @default "/health"
   */
  path?: string;

  /**
   * Custom health check handler.
   * Return an object to be serialized as JSON, or throw to signal unhealthy.
   * @default Returns `{ status: "ok" }`
   */
  check?: () => Promise<Record<string, unknown>> | Record<string, unknown>;
};

/**
 * Configuration options for the TypeweaverServer.
 */
export type TypeweaverServerOptions = {
  /**
   * Port to listen on.
   * @default 3000
   */
  port?: number;

  /**
   * Hostname to bind to.
   * @default "0.0.0.0"
   */
  hostname?: string;

  /**
   * Base path prefix for all routes.
   * Applied via Hono's native `basePath()` so all routes (including health check,
   * middleware, and mounted routers) are served under this prefix.
   * Works consistently across `app.request()`, `fetch`, and `start()`.
   * @example "/api/v1"
   */
  basePath?: string;

  /**
   * Enable health check endpoint.
   * - `true`: Enable with defaults (`/health` returning `{ status: "ok" }`)
   * - `false`: Disable health check
   * - `object`: Enable with custom configuration
   * @default true
   */
  healthCheck?: HealthCheckConfig | boolean;

  /**
   * Enable graceful shutdown on SIGTERM and SIGINT signals.
   * Only effective in Node.js. Ignored in Deno/Bun.
   * @default true
   */
  gracefulShutdown?: boolean;

  /**
   * Timeout in milliseconds to wait for in-flight requests during graceful shutdown.
   * After this timeout, the server will force-close.
   * @default 10000
   */
  shutdownTimeout?: number;

  /**
   * Enable automatic X-Request-Id header generation.
   * When enabled, each request receives a unique ID via the `X-Request-Id` response header.
   * If the incoming request already has an `X-Request-Id` header, it is preserved.
   * @default true
   */
  requestId?: boolean;

  /**
   * Lifecycle hooks for server events.
   */
  hooks?: TypeweaverServerLifecycleHooks;
};

/**
 * Production-ready HTTP server for typeweaver-generated Hono routers.
 *
 * Composes multiple TypeweaverHono routers into a single Hono application
 * with production features:
 * - Health check endpoint
 * - Custom middleware via `use()`
 * - Graceful shutdown (SIGTERM/SIGINT) on Node.js
 * - Request ID generation
 * - Base path / prefix support (via Hono native `basePath()`)
 * - Multi-runtime: `start()` for Node.js, `fetch` for Deno/Bun
 *
 * @example Node.js
 * ```ts
 * const server = new TypeweaverServer({ port: 3000, basePath: "/api/v1" });
 * server.route("/", new TodoHono({ requestHandlers: new TodoHandlers() }));
 * await server.start();
 * ```
 *
 * @example Deno
 * ```ts
 * const server = new TypeweaverServer({ basePath: "/api/v1" });
 * server.route("/", new TodoHono({ requestHandlers: new TodoHandlers() }));
 * Deno.serve({ port: 3000 }, server.fetch);
 * ```
 *
 * @example Bun
 * ```ts
 * const server = new TypeweaverServer({ basePath: "/api/v1" });
 * server.route("/", new TodoHono({ requestHandlers: new TodoHandlers() }));
 * Bun.serve({ port: 3000, fetch: server.fetch });
 * ```
 */
export class TypeweaverServer {
  /**
   * The underlying Hono application instance.
   * BasePath is already applied when configured - all routes, middleware, and
   * `app.request()` calls work consistently with the prefix.
   */
  public readonly app: Hono;

  private readonly options: Required<
    Pick<
      TypeweaverServerOptions,
      | "port"
      | "hostname"
      | "gracefulShutdown"
      | "shutdownTimeout"
      | "requestId"
    >
  > &
    TypeweaverServerOptions;

  private server:
    | { close: (callback?: (err?: Error) => void) => unknown }
    | undefined;
  private isShuttingDown = false;
  private signalHandlers: Array<{ signal: string; handler: () => void }> = [];

  public constructor(options: TypeweaverServerOptions = {}) {
    this.options = {
      port: 3000,
      hostname: "0.0.0.0",
      gracefulShutdown: true,
      shutdownTimeout: 10_000,
      requestId: true,
      ...options,
    };

    // Apply basePath via Hono's native basePath() so all routes and middleware
    // consistently include the prefix — in tests (app.request), fetch, and start().
    const hono = new Hono();
    this.app = (
      this.options.basePath ? hono.basePath(this.options.basePath) : hono
    ) as Hono<HonoEnv, HonoSchema, HonoBasePath>;

    this.setupBuiltInMiddleware();
    this.setupHealthCheck();
  }

  /**
   * Register middleware on the server.
   *
   * Middleware is executed for all routes in the order it is registered.
   * Call this before `route()` to ensure middleware runs before request handlers.
   *
   * @param path - Optional path pattern to scope the middleware (default: all routes)
   * @param handlers - One or more Hono middleware handlers
   * @returns this (for chaining)
   *
   * @example
   * ```ts
   * import { cors } from "hono/cors";
   * import { logger } from "hono/logger";
   *
   * server
   *   .use(logger())
   *   .use("/admin/*", authMiddleware)
   *   .use(cors({ origin: "https://example.com" }))
   *   .route("/", todoRouter);
   * ```
   */
  public use(
    pathOrHandler: string | MiddlewareHandler,
    ...handlers: MiddlewareHandler[]
  ): this {
    if (typeof pathOrHandler === "string") {
      this.app.use(pathOrHandler, ...handlers);
    } else {
      this.app.use(pathOrHandler, ...handlers);
    }
    return this;
  }

  /**
   * Mount a Hono router (typically a generated TypeweaverHono instance) onto the server.
   *
   * @param path - The path prefix for the router
   * @param router - The Hono router instance to mount
   * @returns this (for chaining)
   */
  public route<SubPath extends string>(
    path: SubPath,
    router: Hono<any, any, any>
  ): this {
    this.app.route(path, router);
    return this;
  }

  /**
   * Start the server using `@hono/node-server`.
   * Requires `@hono/node-server` to be installed.
   *
   * For Deno/Bun, use the `fetch` property instead:
   * - Deno: `Deno.serve({ port: 3000 }, server.fetch)`
   * - Bun: `Bun.serve({ port: 3000, fetch: server.fetch })`
   */
  public async start(): Promise<void> {
    if (this.server) {
      throw new Error("Server is already running.");
    }

    const { port, hostname } = this.options;

    // Dynamically import @hono/node-server to keep it optional
    const { serve } = await import("@hono/node-server");

    this.server = serve({
      fetch: this.app.fetch,
      port,
      hostname,
    });

    if (this.options.gracefulShutdown) {
      this.registerSignalHandlers();
    }

    this.options.hooks?.onStarted?.({ port, hostname });
  }

  /**
   * Stop the server gracefully.
   * Waits for in-flight requests to complete up to `shutdownTimeout`.
   */
  public async stop(): Promise<void> {
    if (!this.server || this.isShuttingDown) {
      return;
    }

    this.isShuttingDown = true;

    await this.options.hooks?.onStopping?.();

    await this.closeServer();

    this.removeSignalHandlers();
    this.server = undefined;
    this.isShuttingDown = false;
  }

  /**
   * The Fetch API handler for the server.
   * Use this with Deno.serve() or Bun.serve() for multi-runtime support.
   *
   * BasePath is already applied — the returned handler expects the full path
   * including the prefix.
   */
  public get fetch(): (request: Request) => Response | Promise<Response> {
    return this.app.fetch;
  }

  /**
   * Whether the server is currently running.
   */
  public get isRunning(): boolean {
    return this.server !== undefined && !this.isShuttingDown;
  }

  private setupBuiltInMiddleware(): void {
    if (this.options.requestId) {
      this.app.use(async (c, next) => {
        const existingId = c.req.header("x-request-id");
        const requestId = existingId ?? crypto.randomUUID();

        c.header("X-Request-Id", requestId);
        await next();
      });
    }
  }

  private setupHealthCheck(): void {
    const { healthCheck } = this.options;

    if (healthCheck === false) {
      return;
    }

    const config: HealthCheckConfig =
      healthCheck === true || healthCheck === undefined ? {} : healthCheck;

    const healthPath = config.path ?? "/health";
    const checkFn = config.check ?? (() => ({ status: "ok" }));

    this.app.get(healthPath, async c => {
      try {
        const result = await checkFn();
        return c.json(result, 200);
      } catch (error) {
        const message =
          error instanceof Error ? error.message : "Health check failed";
        return c.json({ status: "error", message }, 503);
      }
    });
  }

  private registerSignalHandlers(): void {
    // Guard for non-Node.js runtimes where process may not exist
    if (typeof process === "undefined" || !process.on) {
      return;
    }

    const shutdown = () => {
      void this.stop();
    };

    for (const signal of ["SIGTERM", "SIGINT"] as const) {
      const handler = shutdown;
      this.signalHandlers.push({ signal, handler });
      process.on(signal, handler);
    }
  }

  private removeSignalHandlers(): void {
    if (typeof process === "undefined" || !process.removeListener) {
      return;
    }

    for (const { signal, handler } of this.signalHandlers) {
      process.removeListener(signal, handler);
    }
    this.signalHandlers = [];
  }

  private async closeServer(): Promise<void> {
    if (!this.server) return;

    return new Promise<void>(resolve => {
      const timeout = setTimeout(() => {
        resolve();
      }, this.options.shutdownTimeout);

      this.server!.close((err?: Error) => {
        clearTimeout(timeout);
        resolve();
      });
    });
  }
}
