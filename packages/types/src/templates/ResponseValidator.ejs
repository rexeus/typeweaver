/* eslint-disable */
/**
 * This file was automatically generated by TypeWeaver.
 * DO NOT EDIT. Instead, modify the source definition file and generate again.
 * 
 * @generated by @rexeus/typeweaver
 */

import definition from "<%= sourcePath %>";
import type { ZodSafeParseResult } from "zod/v4";
import { 
    type IHttpResponse,
    type SafeResponseValidationResult,
    ResponseValidationError
} from "@rexeus/typeweaver-core";
import {
    ResponseValidator,
    assert,
} from "../lib/types";
import {
type <%= pascalCaseOperationId %>Response,
<% for (const ownResponse of ownResponses) { %>
    type I<%= ownResponse.name %>Response,
    <%= ownResponse.name %>Response,
    <% if (ownResponse.hasBody) { %>
    type I<%= ownResponse.name %>ResponseBody,<% } %>
    <% if (ownResponse.hasHeader) { %>
    type I<%= ownResponse.name %>ResponseHeader,<% } %>
<% } %>
} from "<%= responseFile %>";
<% for (const sharedResponse of sharedResponses) { %>
    import {
        type I<%= sharedResponse.name %>Response,
        <%= sharedResponse.name %>Response,
        <% if (sharedResponse.hasBody) { %>
        type I<%= sharedResponse.name %>ResponseBody,<% } %>
        <% if (sharedResponse.hasHeader) { %>
        type I<%= sharedResponse.name %>ResponseHeader,<% } %>
    } from "<%= sharedResponse.importPath %>";
<% } %>

export class <%= pascalCaseOperationId %>ResponseValidator extends ResponseValidator {
    public safeValidate(response: IHttpResponse): SafeResponseValidationResult<<%= pascalCaseOperationId %>Response> {
        const result = this.validateAgainstDefinedResponses(response);

        if(!result.isValid && !result.error.hasResponseIssues()) {
            result.error.addStatusCodeIssue([
                <% const sortedStatusCodes = allStatusCodes.map(statusCode => statusCode.statusCode).sort() %>
                <% for (const statusCode of sortedStatusCodes) { %><%= statusCode %>,<% } %>
            ]);
        }

        return result;
    }

    public validate(response: IHttpResponse): <%= pascalCaseOperationId %>Response {
        const result = this.safeValidate(response);
    
        if (!result.isValid) {
          throw result.error;
        }
    
        return result.data;
    }

    private validateAgainstDefinedResponses(response: IHttpResponse): SafeResponseValidationResult<<%= pascalCaseOperationId %>Response> {
        const error = new ResponseValidationError(response.statusCode);

        <% for (const statusCode of allStatusCodes) { %>
            if (response.statusCode === <%= statusCode.statusCode %>) {
            <%
            for (const response of [...ownResponses, ...sharedResponses]) {
            if (response.statusCode === statusCode.statusCode) {
            %>
                const validate<%= response.name %>ResponseResult = this.validate<%= response.name %>Response(response, error);
                if (validate<%= response.name %>ResponseResult.isValid) {
                    return validate<%= response.name %>ResponseResult;
                }
            <% } } %>
            }

        <% } %>

        return {
            isValid: false,
            error
        };
    }

    <% for (const response of [...ownResponses, ...sharedResponses]) { %>
    private validate<%= response.name %>Response(response: IHttpResponse, error: ResponseValidationError): SafeResponseValidationResult<<%= response.name %>Response> {
        let isValid = true;
        const validatedResponse: IHttpResponse = {
            statusCode: response.statusCode,
            header: undefined,
            body: undefined,
        };

        <% if(response.hasBody) { %>
            assert(
                definition.responses[<%= response.index %>] 
                && "body" in definition.responses[<%= response.index %>] 
                && definition.responses[<%= response.index %>].body,
                "'<%= response.name %>ResponseBody' has to be defined in the definition"
            );
            const validateBodyResult = definition.responses[<%= response.index %>].body.safeParse(response.body) as unknown as ZodSafeParseResult<I<%= response.name %>ResponseBody>;

            if (!validateBodyResult.success) {
                error.addBodyIssues("<%= response.name.replace(/Response$/, '') %>", validateBodyResult.error.issues);
                isValid = false;
            } else {
                validatedResponse.body = validateBodyResult.data;
            }
        <% } %>

        <% if(response.hasHeader) { %>
            assert(
                definition.responses[<%= response.index %>] 
                && "header" in definition.responses[<%= response.index %>] 
                && definition.responses[<%= response.index %>].header,
                "'<%= response.name %>ResponseHeader' has to be defined in the definition"
            );
            const coercedHeader = this.coerceHeaderToSchema(response.header, definition.responses[<%= response.index %>].header.shape);
            const validateHeaderResult = definition.responses[<%= response.index %>].header.safeParse(coercedHeader) as unknown as ZodSafeParseResult<I<%= response.name %>ResponseHeader>;

            if (!validateHeaderResult.success) {
                error.addHeaderIssues("<%= response.name.replace(/Response$/, '') %>", validateHeaderResult.error.issues);
                isValid = false;
            } else {
                validatedResponse.header = validateHeaderResult.data;
            }
        <% } %>

        if (!isValid) {
            return { isValid: false, error };
        }

        return { isValid: true, data: new <%= response.name %>Response(validatedResponse as I<%= response.name %>Response) };
    }
    <% } %>
}